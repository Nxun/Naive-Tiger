//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.3.1.7705
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.3.1.7705 Tiger.g3 2011-06-16 16:37:15

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162


	using NaiveTigerCompiler.AbstractSyntax;
	using NaiveTigerCompiler.SymbolTable;


using System.Collections.Generic;
using Antlr.Runtime;

namespace NaiveTigerCompiler
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.3.1.7705")]
[System.CLSCompliant(false)]
public partial class TigerParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "And", "Array", "Assign", "BlockComment", "Break", "Colon", "Comma", "Divide", "Do", "Dot", "Else", "End", "Equal", "For", "Function", "GreaterEqual", "GreaterThan", "Identifier", "If", "In", "IntegerLiteral", "LeftBrace", "LeftBrack", "LeftParen", "LessEqual", "LessThan", "Let", "LineComment", "Minus", "Nil", "NotEqual", "Of", "Or", "Plus", "RightBrace", "RightBrack", "RightParen", "Semicolon", "StringLiteral", "Then", "Times", "To", "Type", "Var", "While", "WhiteSpace"
	};
	public const int EOF=-1;
	public const int And=4;
	public const int Array=5;
	public const int Assign=6;
	public const int BlockComment=7;
	public const int Break=8;
	public const int Colon=9;
	public const int Comma=10;
	public const int Divide=11;
	public const int Do=12;
	public const int Dot=13;
	public const int Else=14;
	public const int End=15;
	public const int Equal=16;
	public const int For=17;
	public const int Function=18;
	public const int GreaterEqual=19;
	public const int GreaterThan=20;
	public const int Identifier=21;
	public const int If=22;
	public const int In=23;
	public const int IntegerLiteral=24;
	public const int LeftBrace=25;
	public const int LeftBrack=26;
	public const int LeftParen=27;
	public const int LessEqual=28;
	public const int LessThan=29;
	public const int Let=30;
	public const int LineComment=31;
	public const int Minus=32;
	public const int Nil=33;
	public const int NotEqual=34;
	public const int Of=35;
	public const int Or=36;
	public const int Plus=37;
	public const int RightBrace=38;
	public const int RightBrack=39;
	public const int RightParen=40;
	public const int Semicolon=41;
	public const int StringLiteral=42;
	public const int Then=43;
	public const int Times=44;
	public const int To=45;
	public const int Type=46;
	public const int Var=47;
	public const int While=48;
	public const int WhiteSpace=49;

	// delegates
	// delegators

	public TigerParser( ITokenStream input )
		: this( input, new RecognizerSharedState() )
	{
	}
	public TigerParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		this.state.ruleMemo = new System.Collections.Generic.Dictionary<int, int>[37+1];


		OnCreated();
	}
		

	public override string[] TokenNames { get { return TigerParser.tokenNames; } }
	public override string GrammarFileName { get { return "Tiger.g3"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules

	partial void EnterRule_program();
	partial void LeaveRule_program();

	// $ANTLR start "program"
	// Tiger.g3:25:1: public program returns [Expression r] : expression ;
	[GrammarRule("program")]
	public Expression program()
	{
		EnterRule_program();
		EnterRule("program", 1);
		TraceIn("program", 1);
		Expression r = default(Expression);

		Expression expression1 = default(Expression);

		try { DebugEnterRule(GrammarFileName, "program");
		DebugLocation(25, 1);
		try
		{
			// Tiger.g3:26:2: ( expression )
			DebugEnterAlt(1);
			// Tiger.g3:26:4: expression
			{
			DebugLocation(26, 4);
			PushFollow(Follow._expression_in_program66);
			expression1=expression();
			PopFollow();
			if (state.failed) return r;
			DebugLocation(27, 3);
			if (state.backtracking == 0)
			{

							r = expression1;
						
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("program", 1);
			LeaveRule("program", 1);
			LeaveRule_program();
		}
		DebugLocation(30, 1);
		} finally { DebugExitRule(GrammarFileName, "program"); }
		return r;

	}
	// $ANTLR end "program"


	partial void EnterRule_expression();
	partial void LeaveRule_expression();

	// $ANTLR start "expression"
	// Tiger.g3:32:1: expression returns [Expression r] : orExpression ;
	[GrammarRule("expression")]
	private Expression expression()
	{
		EnterRule_expression();
		EnterRule("expression", 2);
		TraceIn("expression", 2);
		Expression r = default(Expression);

		Expression orExpression2 = default(Expression);

		try { DebugEnterRule(GrammarFileName, "expression");
		DebugLocation(32, 1);
		try
		{
			// Tiger.g3:33:2: ( orExpression )
			DebugEnterAlt(1);
			// Tiger.g3:33:4: orExpression
			{
			DebugLocation(33, 4);
			PushFollow(Follow._orExpression_in_expression85);
			orExpression2=orExpression();
			PopFollow();
			if (state.failed) return r;
			DebugLocation(34, 3);
			if (state.backtracking == 0)
			{

							r = orExpression2;
						
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expression", 2);
			LeaveRule("expression", 2);
			LeaveRule_expression();
		}
		DebugLocation(37, 1);
		} finally { DebugExitRule(GrammarFileName, "expression"); }
		return r;

	}
	// $ANTLR end "expression"


	partial void EnterRule_orExpression();
	partial void LeaveRule_orExpression();

	// $ANTLR start "orExpression"
	// Tiger.g3:39:1: orExpression returns [Expression r] : a= andExpression ( Or b= andExpression )* ;
	[GrammarRule("orExpression")]
	private Expression orExpression()
	{
		EnterRule_orExpression();
		EnterRule("orExpression", 3);
		TraceIn("orExpression", 3);
		Expression r = default(Expression);

		CommonToken Or3 = default(CommonToken);
		Expression a = default(Expression);
		Expression b = default(Expression);

		try { DebugEnterRule(GrammarFileName, "orExpression");
		DebugLocation(39, 1);
		try
		{
			// Tiger.g3:40:2: (a= andExpression ( Or b= andExpression )* )
			DebugEnterAlt(1);
			// Tiger.g3:40:4: a= andExpression ( Or b= andExpression )*
			{
			DebugLocation(40, 6);
			PushFollow(Follow._andExpression_in_orExpression108);
			a=andExpression();
			PopFollow();
			if (state.failed) return r;
			DebugLocation(41, 3);
			if (state.backtracking == 0)
			{

							r = a;
						
			}
			DebugLocation(44, 3);
			// Tiger.g3:44:3: ( Or b= andExpression )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if ((LA1_0==Or))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// Tiger.g3:44:4: Or b= andExpression
					{
					DebugLocation(44, 4);
					Or3=(CommonToken)Match(input,Or,Follow._Or_in_orExpression117); if (state.failed) return r;
					DebugLocation(44, 9);
					PushFollow(Follow._andExpression_in_orExpression123);
					b=andExpression();
					PopFollow();
					if (state.failed) return r;
					DebugLocation(45, 3);
					if (state.backtracking == 0)
					{

									r = new IfExpression(new Position(Or3), r, new IntegerExpression(new Position(Or3), 1), b);
								
					}

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("orExpression", 3);
			LeaveRule("orExpression", 3);
			LeaveRule_orExpression();
		}
		DebugLocation(49, 1);
		} finally { DebugExitRule(GrammarFileName, "orExpression"); }
		return r;

	}
	// $ANTLR end "orExpression"


	partial void EnterRule_andExpression();
	partial void LeaveRule_andExpression();

	// $ANTLR start "andExpression"
	// Tiger.g3:51:1: andExpression returns [Expression r] : a= relationalExpression ( And b= relationalExpression )* ;
	[GrammarRule("andExpression")]
	private Expression andExpression()
	{
		EnterRule_andExpression();
		EnterRule("andExpression", 4);
		TraceIn("andExpression", 4);
		Expression r = default(Expression);

		CommonToken And4 = default(CommonToken);
		Expression a = default(Expression);
		Expression b = default(Expression);

		try { DebugEnterRule(GrammarFileName, "andExpression");
		DebugLocation(51, 1);
		try
		{
			// Tiger.g3:52:2: (a= relationalExpression ( And b= relationalExpression )* )
			DebugEnterAlt(1);
			// Tiger.g3:52:4: a= relationalExpression ( And b= relationalExpression )*
			{
			DebugLocation(52, 6);
			PushFollow(Follow._relationalExpression_in_andExpression152);
			a=relationalExpression();
			PopFollow();
			if (state.failed) return r;
			DebugLocation(53, 3);
			if (state.backtracking == 0)
			{

							r = a;
						
			}
			DebugLocation(56, 3);
			// Tiger.g3:56:3: ( And b= relationalExpression )*
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, false);
				int LA2_0 = input.LA(1);

				if ((LA2_0==And))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch ( alt2 )
				{
				case 1:
					DebugEnterAlt(1);
					// Tiger.g3:56:4: And b= relationalExpression
					{
					DebugLocation(56, 4);
					And4=(CommonToken)Match(input,And,Follow._And_in_andExpression161); if (state.failed) return r;
					DebugLocation(56, 10);
					PushFollow(Follow._relationalExpression_in_andExpression167);
					b=relationalExpression();
					PopFollow();
					if (state.failed) return r;
					DebugLocation(57, 3);
					if (state.backtracking == 0)
					{

									r = new IfExpression(new Position(And4), r, b, new IntegerExpression(new Position(And4), 0));
								
					}

					}
					break;

				default:
					goto loop2;
				}
			}

			loop2:
				;

			} finally { DebugExitSubRule(2); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("andExpression", 4);
			LeaveRule("andExpression", 4);
			LeaveRule_andExpression();
		}
		DebugLocation(61, 1);
		} finally { DebugExitRule(GrammarFileName, "andExpression"); }
		return r;

	}
	// $ANTLR end "andExpression"


	partial void EnterRule_relationalExpression();
	partial void LeaveRule_relationalExpression();

	// $ANTLR start "relationalExpression"
	// Tiger.g3:63:1: relationalExpression returns [Expression r] : a= additiveExpression ( (o= Equal |o= NotEqual |o= LessThan |o= LessEqual |o= GreaterThan |o= GreaterEqual ) b= additiveExpression )? ;
	[GrammarRule("relationalExpression")]
	private Expression relationalExpression()
	{
		EnterRule_relationalExpression();
		EnterRule("relationalExpression", 5);
		TraceIn("relationalExpression", 5);
		Expression r = default(Expression);

		CommonToken o = default(CommonToken);
		Expression a = default(Expression);
		Expression b = default(Expression);


			Operator op = 0;

		try { DebugEnterRule(GrammarFileName, "relationalExpression");
		DebugLocation(63, 1);
		try
		{
			// Tiger.g3:68:2: (a= additiveExpression ( (o= Equal |o= NotEqual |o= LessThan |o= LessEqual |o= GreaterThan |o= GreaterEqual ) b= additiveExpression )? )
			DebugEnterAlt(1);
			// Tiger.g3:68:4: a= additiveExpression ( (o= Equal |o= NotEqual |o= LessThan |o= LessEqual |o= GreaterThan |o= GreaterEqual ) b= additiveExpression )?
			{
			DebugLocation(68, 6);
			PushFollow(Follow._additiveExpression_in_relationalExpression200);
			a=additiveExpression();
			PopFollow();
			if (state.failed) return r;
			DebugLocation(69, 3);
			if (state.backtracking == 0)
			{

							r = a;
						
			}
			DebugLocation(72, 3);
			// Tiger.g3:72:3: ( (o= Equal |o= NotEqual |o= LessThan |o= LessEqual |o= GreaterThan |o= GreaterEqual ) b= additiveExpression )?
			int alt4=2;
			try { DebugEnterSubRule(4);
			try { DebugEnterDecision(4, false);
			switch (input.LA(1))
			{
			case Equal:
				{
				alt4 = 1;
				}
				break;
			case NotEqual:
				{
				alt4 = 1;
				}
				break;
			case LessThan:
				{
				alt4 = 1;
				}
				break;
			case LessEqual:
				{
				alt4 = 1;
				}
				break;
			case GreaterThan:
				{
				alt4 = 1;
				}
				break;
			case GreaterEqual:
				{
				alt4 = 1;
				}
				break;
			}

			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// Tiger.g3:72:4: (o= Equal |o= NotEqual |o= LessThan |o= LessEqual |o= GreaterThan |o= GreaterEqual ) b= additiveExpression
				{
				DebugLocation(72, 4);
				// Tiger.g3:72:4: (o= Equal |o= NotEqual |o= LessThan |o= LessEqual |o= GreaterThan |o= GreaterEqual )
				int alt3=6;
				try { DebugEnterSubRule(3);
				try { DebugEnterDecision(3, false);
				switch (input.LA(1))
				{
				case Equal:
					{
					alt3 = 1;
					}
					break;
				case NotEqual:
					{
					alt3 = 2;
					}
					break;
				case LessThan:
					{
					alt3 = 3;
					}
					break;
				case LessEqual:
					{
					alt3 = 4;
					}
					break;
				case GreaterThan:
					{
					alt3 = 5;
					}
					break;
				case GreaterEqual:
					{
					alt3 = 6;
					}
					break;
				default:
					{
						if (state.backtracking>0) {state.failed=true; return r;}
						NoViableAltException nvae = new NoViableAltException("", 3, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				} finally { DebugExitDecision(3); }
				switch (alt3)
				{
				case 1:
					DebugEnterAlt(1);
					// Tiger.g3:73:4: o= Equal
					{
					DebugLocation(73, 6);
					o=(CommonToken)Match(input,Equal,Follow._Equal_in_relationalExpression218); if (state.failed) return r;
					DebugLocation(73, 14);
					if (state.backtracking == 0)
					{
						op = Operator.Equal;
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Tiger.g3:74:5: o= NotEqual
					{
					DebugLocation(74, 7);
					o=(CommonToken)Match(input,NotEqual,Follow._NotEqual_in_relationalExpression230); if (state.failed) return r;
					DebugLocation(74, 18);
					if (state.backtracking == 0)
					{
						op = Operator.NotEqual;
					}

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// Tiger.g3:75:5: o= LessThan
					{
					DebugLocation(75, 7);
					o=(CommonToken)Match(input,LessThan,Follow._LessThan_in_relationalExpression242); if (state.failed) return r;
					DebugLocation(75, 18);
					if (state.backtracking == 0)
					{
						op = Operator.LessThan;
					}

					}
					break;
				case 4:
					DebugEnterAlt(4);
					// Tiger.g3:76:5: o= LessEqual
					{
					DebugLocation(76, 7);
					o=(CommonToken)Match(input,LessEqual,Follow._LessEqual_in_relationalExpression254); if (state.failed) return r;
					DebugLocation(76, 19);
					if (state.backtracking == 0)
					{
						op = Operator.LessEqual;
					}

					}
					break;
				case 5:
					DebugEnterAlt(5);
					// Tiger.g3:77:5: o= GreaterThan
					{
					DebugLocation(77, 7);
					o=(CommonToken)Match(input,GreaterThan,Follow._GreaterThan_in_relationalExpression266); if (state.failed) return r;
					DebugLocation(77, 21);
					if (state.backtracking == 0)
					{
						op = Operator.GreaterThan;
					}

					}
					break;
				case 6:
					DebugEnterAlt(6);
					// Tiger.g3:78:5: o= GreaterEqual
					{
					DebugLocation(78, 7);
					o=(CommonToken)Match(input,GreaterEqual,Follow._GreaterEqual_in_relationalExpression278); if (state.failed) return r;
					DebugLocation(78, 22);
					if (state.backtracking == 0)
					{
						op = Operator.GreaterThan;
					}

					}
					break;

				}
				} finally { DebugExitSubRule(3); }

				DebugLocation(79, 7);
				PushFollow(Follow._additiveExpression_in_relationalExpression290);
				b=additiveExpression();
				PopFollow();
				if (state.failed) return r;
				DebugLocation(80, 3);
				if (state.backtracking == 0)
				{

								r = new OperatorExpression(new Position(o), a, op, b);
							
				}

				}
				break;

			}
			} finally { DebugExitSubRule(4); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("relationalExpression", 5);
			LeaveRule("relationalExpression", 5);
			LeaveRule_relationalExpression();
		}
		DebugLocation(83, 1);
		} finally { DebugExitRule(GrammarFileName, "relationalExpression"); }
		return r;

	}
	// $ANTLR end "relationalExpression"


	partial void EnterRule_additiveExpression();
	partial void LeaveRule_additiveExpression();

	// $ANTLR start "additiveExpression"
	// Tiger.g3:85:1: additiveExpression returns [Expression r] : a= multiplicativeExpression ( (o= Plus |o= Minus ) b= multiplicativeExpression )* ;
	[GrammarRule("additiveExpression")]
	private Expression additiveExpression()
	{
		EnterRule_additiveExpression();
		EnterRule("additiveExpression", 6);
		TraceIn("additiveExpression", 6);
		Expression r = default(Expression);

		CommonToken o = default(CommonToken);
		Expression a = default(Expression);
		Expression b = default(Expression);


			Operator op = 0;

		try { DebugEnterRule(GrammarFileName, "additiveExpression");
		DebugLocation(85, 1);
		try
		{
			// Tiger.g3:90:2: (a= multiplicativeExpression ( (o= Plus |o= Minus ) b= multiplicativeExpression )* )
			DebugEnterAlt(1);
			// Tiger.g3:90:4: a= multiplicativeExpression ( (o= Plus |o= Minus ) b= multiplicativeExpression )*
			{
			DebugLocation(90, 6);
			PushFollow(Follow._multiplicativeExpression_in_additiveExpression320);
			a=multiplicativeExpression();
			PopFollow();
			if (state.failed) return r;
			DebugLocation(91, 3);
			if (state.backtracking == 0)
			{

							r = a;
						
			}
			DebugLocation(94, 3);
			// Tiger.g3:94:3: ( (o= Plus |o= Minus ) b= multiplicativeExpression )*
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=2;
				try { DebugEnterDecision(6, false);
				int LA6_0 = input.LA(1);

				if ((LA6_0==Plus))
				{
					alt6 = 1;
				}
				else if ((LA6_0==Minus))
				{
					alt6 = 1;
				}


				} finally { DebugExitDecision(6); }
				switch ( alt6 )
				{
				case 1:
					DebugEnterAlt(1);
					// Tiger.g3:94:4: (o= Plus |o= Minus ) b= multiplicativeExpression
					{
					DebugLocation(94, 4);
					// Tiger.g3:94:4: (o= Plus |o= Minus )
					int alt5=2;
					try { DebugEnterSubRule(5);
					try { DebugEnterDecision(5, false);
					int LA5_0 = input.LA(1);

					if ((LA5_0==Plus))
					{
						alt5 = 1;
					}
					else if ((LA5_0==Minus))
					{
						alt5 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return r;}
						NoViableAltException nvae = new NoViableAltException("", 5, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(5); }
					switch (alt5)
					{
					case 1:
						DebugEnterAlt(1);
						// Tiger.g3:95:4: o= Plus
						{
						DebugLocation(95, 6);
						o=(CommonToken)Match(input,Plus,Follow._Plus_in_additiveExpression338); if (state.failed) return r;
						DebugLocation(95, 13);
						if (state.backtracking == 0)
						{
							op = Operator.Plus;
						}

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// Tiger.g3:96:5: o= Minus
						{
						DebugLocation(96, 7);
						o=(CommonToken)Match(input,Minus,Follow._Minus_in_additiveExpression350); if (state.failed) return r;
						DebugLocation(96, 15);
						if (state.backtracking == 0)
						{
							op = Operator.Minus;
						}

						}
						break;

					}
					} finally { DebugExitSubRule(5); }

					DebugLocation(97, 7);
					PushFollow(Follow._multiplicativeExpression_in_additiveExpression362);
					b=multiplicativeExpression();
					PopFollow();
					if (state.failed) return r;
					DebugLocation(98, 3);
					if (state.backtracking == 0)
					{

									r = new OperatorExpression(new Position(o), r, op, b);
								
					}

					}
					break;

				default:
					goto loop6;
				}
			}

			loop6:
				;

			} finally { DebugExitSubRule(6); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("additiveExpression", 6);
			LeaveRule("additiveExpression", 6);
			LeaveRule_additiveExpression();
		}
		DebugLocation(102, 1);
		} finally { DebugExitRule(GrammarFileName, "additiveExpression"); }
		return r;

	}
	// $ANTLR end "additiveExpression"


	partial void EnterRule_multiplicativeExpression();
	partial void LeaveRule_multiplicativeExpression();

	// $ANTLR start "multiplicativeExpression"
	// Tiger.g3:104:1: multiplicativeExpression returns [Expression r] : a= expressionAtom ( (o= Times |o= Divide ) b= expressionAtom )* ;
	[GrammarRule("multiplicativeExpression")]
	private Expression multiplicativeExpression()
	{
		EnterRule_multiplicativeExpression();
		EnterRule("multiplicativeExpression", 7);
		TraceIn("multiplicativeExpression", 7);
		Expression r = default(Expression);

		CommonToken o = default(CommonToken);
		Expression a = default(Expression);
		Expression b = default(Expression);


			Operator op = 0;

		try { DebugEnterRule(GrammarFileName, "multiplicativeExpression");
		DebugLocation(104, 1);
		try
		{
			// Tiger.g3:109:2: (a= expressionAtom ( (o= Times |o= Divide ) b= expressionAtom )* )
			DebugEnterAlt(1);
			// Tiger.g3:109:4: a= expressionAtom ( (o= Times |o= Divide ) b= expressionAtom )*
			{
			DebugLocation(109, 6);
			PushFollow(Follow._expressionAtom_in_multiplicativeExpression395);
			a=expressionAtom();
			PopFollow();
			if (state.failed) return r;
			DebugLocation(110, 3);
			if (state.backtracking == 0)
			{

							r = a;
						
			}
			DebugLocation(113, 3);
			// Tiger.g3:113:3: ( (o= Times |o= Divide ) b= expressionAtom )*
			try { DebugEnterSubRule(8);
			while (true)
			{
				int alt8=2;
				try { DebugEnterDecision(8, false);
				int LA8_0 = input.LA(1);

				if ((LA8_0==Times))
				{
					alt8 = 1;
				}
				else if ((LA8_0==Divide))
				{
					alt8 = 1;
				}


				} finally { DebugExitDecision(8); }
				switch ( alt8 )
				{
				case 1:
					DebugEnterAlt(1);
					// Tiger.g3:113:4: (o= Times |o= Divide ) b= expressionAtom
					{
					DebugLocation(113, 4);
					// Tiger.g3:113:4: (o= Times |o= Divide )
					int alt7=2;
					try { DebugEnterSubRule(7);
					try { DebugEnterDecision(7, false);
					int LA7_0 = input.LA(1);

					if ((LA7_0==Times))
					{
						alt7 = 1;
					}
					else if ((LA7_0==Divide))
					{
						alt7 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return r;}
						NoViableAltException nvae = new NoViableAltException("", 7, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(7); }
					switch (alt7)
					{
					case 1:
						DebugEnterAlt(1);
						// Tiger.g3:114:4: o= Times
						{
						DebugLocation(114, 6);
						o=(CommonToken)Match(input,Times,Follow._Times_in_multiplicativeExpression413); if (state.failed) return r;
						DebugLocation(114, 14);
						if (state.backtracking == 0)
						{
							op = Operator.Times;
						}

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// Tiger.g3:115:5: o= Divide
						{
						DebugLocation(115, 7);
						o=(CommonToken)Match(input,Divide,Follow._Divide_in_multiplicativeExpression425); if (state.failed) return r;
						DebugLocation(115, 16);
						if (state.backtracking == 0)
						{
							op = Operator.Divide;
						}

						}
						break;

					}
					} finally { DebugExitSubRule(7); }

					DebugLocation(116, 7);
					PushFollow(Follow._expressionAtom_in_multiplicativeExpression437);
					b=expressionAtom();
					PopFollow();
					if (state.failed) return r;
					DebugLocation(117, 3);
					if (state.backtracking == 0)
					{

									r = new OperatorExpression(new Position(o), r, op, b);
								
					}

					}
					break;

				default:
					goto loop8;
				}
			}

			loop8:
				;

			} finally { DebugExitSubRule(8); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("multiplicativeExpression", 7);
			LeaveRule("multiplicativeExpression", 7);
			LeaveRule_multiplicativeExpression();
		}
		DebugLocation(121, 1);
		} finally { DebugExitRule(GrammarFileName, "multiplicativeExpression"); }
		return r;

	}
	// $ANTLR end "multiplicativeExpression"

	protected sealed partial class expressionAtom_scope
	{
		public Expression rr;

		public expressionAtom_scope(TigerParser grammar) { OnCreated(grammar); }
		partial void OnCreated(TigerParser grammar);
	}
	partial void expressionAtom_scopeInit( expressionAtom_scope scope );
	partial void expressionAtom_scopeAfter( expressionAtom_scope scope );
	protected readonly Stack<expressionAtom_scope> expressionAtom_stack = new Stack<expressionAtom_scope>();


	partial void EnterRule_expressionAtom();
	partial void LeaveRule_expressionAtom();

	// $ANTLR start "expressionAtom"
	// Tiger.g3:124:1: expressionAtom returns [Expression r] options {backtrack=true; memoize=true; } : ( StringLiteral | IntegerLiteral | Nil | Minus expression | lvalue Assign expression | Identifier LeftParen ( expressionList )? RightParen | LeftParen ( expressionSequence )? RightParen | Identifier LeftBrace fieldList RightBrace | Identifier LeftBrack size= expression RightBrack Of init= expression | If test= expression Then then= expression ( Else els= expression )? | While test= expression Do body= expression | For Identifier Assign e= expression To high= expression Do body= expression | Break | Let declarationList In ( expressionSequence )? End | lvalue );
	[GrammarRule("expressionAtom")]
	private Expression expressionAtom()
	{
		EnterRule_expressionAtom();
		EnterRule("expressionAtom", 8);
		TraceIn("expressionAtom", 8);
		expressionAtom_stack.Push(new expressionAtom_scope(this));expressionAtom_scopeInit(expressionAtom_stack.Peek());
		Expression r = default(Expression);
		int expressionAtom_StartIndex = input.Index;
		CommonToken StringLiteral5 = default(CommonToken);
		CommonToken IntegerLiteral6 = default(CommonToken);
		CommonToken Nil7 = default(CommonToken);
		CommonToken Minus8 = default(CommonToken);
		CommonToken Identifier12 = default(CommonToken);
		CommonToken LeftParen14 = default(CommonToken);
		CommonToken Identifier16 = default(CommonToken);
		CommonToken Identifier18 = default(CommonToken);
		CommonToken If19 = default(CommonToken);
		CommonToken While20 = default(CommonToken);
		CommonToken Identifier21 = default(CommonToken);
		CommonToken For22 = default(CommonToken);
		CommonToken Break23 = default(CommonToken);
		CommonToken In24 = default(CommonToken);
		CommonToken Let26 = default(CommonToken);
		Expression size = default(Expression);
		Expression init = default(Expression);
		Expression test = default(Expression);
		Expression then = default(Expression);
		Expression els = default(Expression);
		Expression body = default(Expression);
		Expression e = default(Expression);
		Expression high = default(Expression);
		Expression expression9 = default(Expression);
		TigerParser.lvalue_return lvalue10 = default(TigerParser.lvalue_return);
		Expression expression11 = default(Expression);
		ExpressionList expressionList13 = default(ExpressionList);
		ExpressionList expressionSequence15 = default(ExpressionList);
		FieldExpressionList fieldList17 = default(FieldExpressionList);
		ExpressionList expressionSequence25 = default(ExpressionList);
		DeclarationList declarationList27 = default(DeclarationList);
		TigerParser.lvalue_return lvalue28 = default(TigerParser.lvalue_return);


			bool flag = false;

		try { DebugEnterRule(GrammarFileName, "expressionAtom");
		DebugLocation(124, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 8)) { return r; }
			// Tiger.g3:145:2: ( StringLiteral | IntegerLiteral | Nil | Minus expression | lvalue Assign expression | Identifier LeftParen ( expressionList )? RightParen | LeftParen ( expressionSequence )? RightParen | Identifier LeftBrace fieldList RightBrace | Identifier LeftBrack size= expression RightBrack Of init= expression | If test= expression Then then= expression ( Else els= expression )? | While test= expression Do body= expression | For Identifier Assign e= expression To high= expression Do body= expression | Break | Let declarationList In ( expressionSequence )? End | lvalue )
			int alt13=15;
			try { DebugEnterDecision(13, false);
			try
			{
				alt13 = dfa13.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(13); }
			switch (alt13)
			{
			case 1:
				DebugEnterAlt(1);
				// Tiger.g3:145:4: StringLiteral
				{
				DebugLocation(145, 4);
				StringLiteral5=(CommonToken)Match(input,StringLiteral,Follow._StringLiteral_in_expressionAtom496); if (state.failed) return r;
				DebugLocation(146, 3);
				if (state.backtracking == 0)
				{

								r = new StringExpression(new Position(StringLiteral5), StringLiteral5.Text);
							
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Tiger.g3:149:4: IntegerLiteral
				{
				DebugLocation(149, 4);
				IntegerLiteral6=(CommonToken)Match(input,IntegerLiteral,Follow._IntegerLiteral_in_expressionAtom505); if (state.failed) return r;
				DebugLocation(150, 3);
				if (state.backtracking == 0)
				{

								r = new IntegerExpression(new Position(IntegerLiteral6), int.Parse(IntegerLiteral6.Text));
							
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Tiger.g3:153:4: Nil
				{
				DebugLocation(153, 4);
				Nil7=(CommonToken)Match(input,Nil,Follow._Nil_in_expressionAtom515); if (state.failed) return r;
				DebugLocation(154, 3);
				if (state.backtracking == 0)
				{

								r = new NilExpression(new Position(Nil7));
							
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Tiger.g3:157:4: Minus expression
				{
				DebugLocation(157, 4);
				Minus8=(CommonToken)Match(input,Minus,Follow._Minus_in_expressionAtom524); if (state.failed) return r;
				DebugLocation(157, 10);
				PushFollow(Follow._expression_in_expressionAtom526);
				expression9=expression();
				PopFollow();
				if (state.failed) return r;
				DebugLocation(158, 3);
				if (state.backtracking == 0)
				{

								r = new OperatorExpression(new Position(Minus8), new IntegerExpression(new Position(Minus8), 0), Operator.Minus, expression9);
							
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Tiger.g3:161:4: lvalue Assign expression
				{
				DebugLocation(161, 4);
				PushFollow(Follow._lvalue_in_expressionAtom536);
				lvalue10=lvalue();
				PopFollow();
				if (state.failed) return r;
				DebugLocation(161, 11);
				Match(input,Assign,Follow._Assign_in_expressionAtom538); if (state.failed) return r;
				DebugLocation(161, 18);
				PushFollow(Follow._expression_in_expressionAtom540);
				expression11=expression();
				PopFollow();
				if (state.failed) return r;
				DebugLocation(162, 3);
				if (state.backtracking == 0)
				{

								expressionAtom_stack.Peek().rr =  new AssignExpression((lvalue10!=null?lvalue10.p:default(Position)), (lvalue10!=null?lvalue10.r:default(Variable)), expression11);
							
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// Tiger.g3:165:4: Identifier LeftParen ( expressionList )? RightParen
				{
				DebugLocation(165, 4);
				Identifier12=(CommonToken)Match(input,Identifier,Follow._Identifier_in_expressionAtom550); if (state.failed) return r;
				DebugLocation(165, 15);
				Match(input,LeftParen,Follow._LeftParen_in_expressionAtom552); if (state.failed) return r;
				DebugLocation(165, 25);
				// Tiger.g3:165:25: ( expressionList )?
				int alt9=2;
				try { DebugEnterSubRule(9);
				try { DebugEnterDecision(9, false);
				int LA9_0 = input.LA(1);

				if ((LA9_0==Break||LA9_0==For||(LA9_0>=Identifier && LA9_0<=If)||LA9_0==IntegerLiteral||LA9_0==LeftParen||LA9_0==Let||(LA9_0>=Minus && LA9_0<=Nil)||LA9_0==StringLiteral||LA9_0==While))
				{
					alt9 = 1;
				}
				} finally { DebugExitDecision(9); }
				switch (alt9)
				{
				case 1:
					DebugEnterAlt(1);
					// Tiger.g3:165:25: expressionList
					{
					DebugLocation(165, 25);
					PushFollow(Follow._expressionList_in_expressionAtom554);
					expressionList13=expressionList();
					PopFollow();
					if (state.failed) return r;

					}
					break;

				}
				} finally { DebugExitSubRule(9); }

				DebugLocation(165, 41);
				Match(input,RightParen,Follow._RightParen_in_expressionAtom557); if (state.failed) return r;
				DebugLocation(166, 3);
				if (state.backtracking == 0)
				{

								expressionAtom_stack.Peek().rr =  new CallExpression(new Position(Identifier12), Symbol.GetSymbol(Identifier12.Text), expressionList13);
							
				}

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// Tiger.g3:169:4: LeftParen ( expressionSequence )? RightParen
				{
				DebugLocation(169, 4);
				LeftParen14=(CommonToken)Match(input,LeftParen,Follow._LeftParen_in_expressionAtom567); if (state.failed) return r;
				DebugLocation(169, 14);
				// Tiger.g3:169:14: ( expressionSequence )?
				int alt10=2;
				try { DebugEnterSubRule(10);
				try { DebugEnterDecision(10, false);
				int LA10_0 = input.LA(1);

				if ((LA10_0==Break||LA10_0==For||(LA10_0>=Identifier && LA10_0<=If)||LA10_0==IntegerLiteral||LA10_0==LeftParen||LA10_0==Let||(LA10_0>=Minus && LA10_0<=Nil)||LA10_0==StringLiteral||LA10_0==While))
				{
					alt10 = 1;
				}
				} finally { DebugExitDecision(10); }
				switch (alt10)
				{
				case 1:
					DebugEnterAlt(1);
					// Tiger.g3:169:14: expressionSequence
					{
					DebugLocation(169, 14);
					PushFollow(Follow._expressionSequence_in_expressionAtom569);
					expressionSequence15=expressionSequence();
					PopFollow();
					if (state.failed) return r;

					}
					break;

				}
				} finally { DebugExitSubRule(10); }

				DebugLocation(169, 34);
				Match(input,RightParen,Follow._RightParen_in_expressionAtom572); if (state.failed) return r;
				DebugLocation(170, 3);
				if (state.backtracking == 0)
				{

								r = new SequenceExpression(new Position(LeftParen14), expressionSequence15);
							
				}

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// Tiger.g3:173:4: Identifier LeftBrace fieldList RightBrace
				{
				DebugLocation(173, 4);
				Identifier16=(CommonToken)Match(input,Identifier,Follow._Identifier_in_expressionAtom582); if (state.failed) return r;
				DebugLocation(173, 15);
				Match(input,LeftBrace,Follow._LeftBrace_in_expressionAtom584); if (state.failed) return r;
				DebugLocation(173, 25);
				PushFollow(Follow._fieldList_in_expressionAtom586);
				fieldList17=fieldList();
				PopFollow();
				if (state.failed) return r;
				DebugLocation(173, 35);
				Match(input,RightBrace,Follow._RightBrace_in_expressionAtom588); if (state.failed) return r;
				DebugLocation(174, 3);
				if (state.backtracking == 0)
				{

								expressionAtom_stack.Peek().rr =  new RecordExpression(new Position(Identifier16), Symbol.GetSymbol(Identifier16.Text), fieldList17);
							
				}

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// Tiger.g3:177:4: Identifier LeftBrack size= expression RightBrack Of init= expression
				{
				DebugLocation(177, 4);
				Identifier18=(CommonToken)Match(input,Identifier,Follow._Identifier_in_expressionAtom598); if (state.failed) return r;
				DebugLocation(177, 15);
				Match(input,LeftBrack,Follow._LeftBrack_in_expressionAtom600); if (state.failed) return r;
				DebugLocation(177, 30);
				PushFollow(Follow._expression_in_expressionAtom606);
				size=expression();
				PopFollow();
				if (state.failed) return r;
				DebugLocation(177, 43);
				Match(input,RightBrack,Follow._RightBrack_in_expressionAtom608); if (state.failed) return r;
				DebugLocation(177, 54);
				Match(input,Of,Follow._Of_in_expressionAtom610); if (state.failed) return r;
				DebugLocation(177, 62);
				PushFollow(Follow._expression_in_expressionAtom616);
				init=expression();
				PopFollow();
				if (state.failed) return r;
				DebugLocation(178, 3);
				if (state.backtracking == 0)
				{

								expressionAtom_stack.Peek().rr =  new ArrayExpression(new Position(Identifier18), Symbol.GetSymbol(Identifier18.Text), size, init);
							
				}

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// Tiger.g3:181:4: If test= expression Then then= expression ( Else els= expression )?
				{
				DebugLocation(181, 4);
				If19=(CommonToken)Match(input,If,Follow._If_in_expressionAtom626); if (state.failed) return r;
				DebugLocation(181, 12);
				PushFollow(Follow._expression_in_expressionAtom632);
				test=expression();
				PopFollow();
				if (state.failed) return r;
				DebugLocation(181, 25);
				Match(input,Then,Follow._Then_in_expressionAtom634); if (state.failed) return r;
				DebugLocation(181, 35);
				PushFollow(Follow._expression_in_expressionAtom640);
				then=expression();
				PopFollow();
				if (state.failed) return r;
				DebugLocation(181, 48);
				// Tiger.g3:181:48: ( Else els= expression )?
				int alt11=2;
				try { DebugEnterSubRule(11);
				try { DebugEnterDecision(11, false);
				int LA11_0 = input.LA(1);

				if ((LA11_0==Else))
				{
					alt11 = 1;
				}
				} finally { DebugExitDecision(11); }
				switch (alt11)
				{
				case 1:
					DebugEnterAlt(1);
					// Tiger.g3:181:49: Else els= expression
					{
					DebugLocation(181, 49);
					Match(input,Else,Follow._Else_in_expressionAtom643); if (state.failed) return r;
					DebugLocation(181, 58);
					PushFollow(Follow._expression_in_expressionAtom649);
					els=expression();
					PopFollow();
					if (state.failed) return r;
					DebugLocation(181, 71);
					if (state.backtracking == 0)
					{
						flag = true;
					}

					}
					break;

				}
				} finally { DebugExitSubRule(11); }

				DebugLocation(182, 3);
				if (state.backtracking == 0)
				{

								if (flag)
								{
									r = new IfExpression(new Position(If19), test, then, els);
								}
								else
								{
									r = new IfExpression(new Position(If19), test, then);
								}
							
				}

				}
				break;
			case 11:
				DebugEnterAlt(11);
				// Tiger.g3:192:4: While test= expression Do body= expression
				{
				DebugLocation(192, 4);
				While20=(CommonToken)Match(input,While,Follow._While_in_expressionAtom663); if (state.failed) return r;
				DebugLocation(192, 15);
				PushFollow(Follow._expression_in_expressionAtom669);
				test=expression();
				PopFollow();
				if (state.failed) return r;
				DebugLocation(192, 28);
				Match(input,Do,Follow._Do_in_expressionAtom671); if (state.failed) return r;
				DebugLocation(192, 36);
				PushFollow(Follow._expression_in_expressionAtom677);
				body=expression();
				PopFollow();
				if (state.failed) return r;
				DebugLocation(193, 3);
				if (state.backtracking == 0)
				{

								r = new WhileExpression(new Position(While20), test, body);
							
				}

				}
				break;
			case 12:
				DebugEnterAlt(12);
				// Tiger.g3:196:4: For Identifier Assign e= expression To high= expression Do body= expression
				{
				DebugLocation(196, 4);
				For22=(CommonToken)Match(input,For,Follow._For_in_expressionAtom687); if (state.failed) return r;
				DebugLocation(196, 8);
				Identifier21=(CommonToken)Match(input,Identifier,Follow._Identifier_in_expressionAtom689); if (state.failed) return r;
				DebugLocation(196, 19);
				Match(input,Assign,Follow._Assign_in_expressionAtom691); if (state.failed) return r;
				DebugLocation(196, 28);
				PushFollow(Follow._expression_in_expressionAtom697);
				e=expression();
				PopFollow();
				if (state.failed) return r;
				DebugLocation(196, 41);
				Match(input,To,Follow._To_in_expressionAtom699); if (state.failed) return r;
				DebugLocation(196, 49);
				PushFollow(Follow._expression_in_expressionAtom705);
				high=expression();
				PopFollow();
				if (state.failed) return r;
				DebugLocation(196, 62);
				Match(input,Do,Follow._Do_in_expressionAtom707); if (state.failed) return r;
				DebugLocation(196, 70);
				PushFollow(Follow._expression_in_expressionAtom713);
				body=expression();
				PopFollow();
				if (state.failed) return r;
				DebugLocation(197, 3);
				if (state.backtracking == 0)
				{

								VariableDeclaration v = new VariableDeclaration(new Position(Identifier21), Symbol.GetSymbol(Identifier21.Text), new NameType(new Position(Identifier21), Symbol.GetSymbol("int")), e);
								r = new ForExpression(new Position(For22), v, high, body);
							
				}

				}
				break;
			case 13:
				DebugEnterAlt(13);
				// Tiger.g3:201:4: Break
				{
				DebugLocation(201, 4);
				Break23=(CommonToken)Match(input,Break,Follow._Break_in_expressionAtom723); if (state.failed) return r;
				DebugLocation(202, 3);
				if (state.backtracking == 0)
				{

								r = new BreakExpression(new Position(Break23));
							
				}

				}
				break;
			case 14:
				DebugEnterAlt(14);
				// Tiger.g3:205:4: Let declarationList In ( expressionSequence )? End
				{
				DebugLocation(205, 4);
				Let26=(CommonToken)Match(input,Let,Follow._Let_in_expressionAtom733); if (state.failed) return r;
				DebugLocation(205, 8);
				PushFollow(Follow._declarationList_in_expressionAtom735);
				declarationList27=declarationList();
				PopFollow();
				if (state.failed) return r;
				DebugLocation(205, 24);
				In24=(CommonToken)Match(input,In,Follow._In_in_expressionAtom737); if (state.failed) return r;
				DebugLocation(205, 27);
				// Tiger.g3:205:27: ( expressionSequence )?
				int alt12=2;
				try { DebugEnterSubRule(12);
				try { DebugEnterDecision(12, false);
				int LA12_0 = input.LA(1);

				if ((LA12_0==Break||LA12_0==For||(LA12_0>=Identifier && LA12_0<=If)||LA12_0==IntegerLiteral||LA12_0==LeftParen||LA12_0==Let||(LA12_0>=Minus && LA12_0<=Nil)||LA12_0==StringLiteral||LA12_0==While))
				{
					alt12 = 1;
				}
				} finally { DebugExitDecision(12); }
				switch (alt12)
				{
				case 1:
					DebugEnterAlt(1);
					// Tiger.g3:205:27: expressionSequence
					{
					DebugLocation(205, 27);
					PushFollow(Follow._expressionSequence_in_expressionAtom739);
					expressionSequence25=expressionSequence();
					PopFollow();
					if (state.failed) return r;

					}
					break;

				}
				} finally { DebugExitSubRule(12); }

				DebugLocation(205, 47);
				Match(input,End,Follow._End_in_expressionAtom742); if (state.failed) return r;
				DebugLocation(206, 3);
				if (state.backtracking == 0)
				{

								SequenceExpression seq = new SequenceExpression(new Position(In24), expressionSequence25);
								r = new LetExpression(new Position(Let26), declarationList27, seq);
							
				}

				}
				break;
			case 15:
				DebugEnterAlt(15);
				// Tiger.g3:210:4: lvalue
				{
				DebugLocation(210, 4);
				PushFollow(Follow._lvalue_in_expressionAtom752);
				lvalue28=lvalue();
				PopFollow();
				if (state.failed) return r;
				DebugLocation(211, 3);
				if (state.backtracking == 0)
				{

								r = new VariableExpression((lvalue28!=null?lvalue28.p:default(Position)), (lvalue28!=null?lvalue28.r:default(Variable)));
							
				}

				}
				break;

			}
			if (state.backtracking == 0)
			{

					if (r == null)
					{
						r = expressionAtom_stack.Peek().rr;
					}

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expressionAtom", 8);
			LeaveRule("expressionAtom", 8);
			LeaveRule_expressionAtom();
			if (state.backtracking > 0) { Memoize(input, 8, expressionAtom_StartIndex); }
			expressionAtom_scopeAfter(expressionAtom_stack.Peek());expressionAtom_stack.Pop();
		}
		DebugLocation(214, 1);
		} finally { DebugExitRule(GrammarFileName, "expressionAtom"); }
		return r;

	}
	// $ANTLR end "expressionAtom"


	partial void EnterRule_expressionSequence();
	partial void LeaveRule_expressionSequence();

	// $ANTLR start "expressionSequence"
	// Tiger.g3:216:1: expressionSequence returns [ExpressionList r] : a= expression ( Semicolon b= expression )* ;
	[GrammarRule("expressionSequence")]
	private ExpressionList expressionSequence()
	{
		EnterRule_expressionSequence();
		EnterRule("expressionSequence", 9);
		TraceIn("expressionSequence", 9);
		ExpressionList r = default(ExpressionList);

		Expression a = default(Expression);
		Expression b = default(Expression);


			ExpressionList t = null;

		try { DebugEnterRule(GrammarFileName, "expressionSequence");
		DebugLocation(216, 1);
		try
		{
			// Tiger.g3:221:2: (a= expression ( Semicolon b= expression )* )
			DebugEnterAlt(1);
			// Tiger.g3:221:4: a= expression ( Semicolon b= expression )*
			{
			DebugLocation(221, 6);
			PushFollow(Follow._expression_in_expressionSequence781);
			a=expression();
			PopFollow();
			if (state.failed) return r;
			DebugLocation(222, 3);
			if (state.backtracking == 0)
			{

							r = new ExpressionList(a, null);
							t = r;
						
			}
			DebugLocation(226, 3);
			// Tiger.g3:226:3: ( Semicolon b= expression )*
			try { DebugEnterSubRule(14);
			while (true)
			{
				int alt14=2;
				try { DebugEnterDecision(14, false);
				int LA14_0 = input.LA(1);

				if ((LA14_0==Semicolon))
				{
					alt14 = 1;
				}


				} finally { DebugExitDecision(14); }
				switch ( alt14 )
				{
				case 1:
					DebugEnterAlt(1);
					// Tiger.g3:226:4: Semicolon b= expression
					{
					DebugLocation(226, 4);
					Match(input,Semicolon,Follow._Semicolon_in_expressionSequence790); if (state.failed) return r;
					DebugLocation(226, 16);
					PushFollow(Follow._expression_in_expressionSequence796);
					b=expression();
					PopFollow();
					if (state.failed) return r;
					DebugLocation(227, 3);
					if (state.backtracking == 0)
					{

									t.Tail = new ExpressionList(b, null);
									t = t.Tail;
								
					}

					}
					break;

				default:
					goto loop14;
				}
			}

			loop14:
				;

			} finally { DebugExitSubRule(14); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expressionSequence", 9);
			LeaveRule("expressionSequence", 9);
			LeaveRule_expressionSequence();
		}
		DebugLocation(232, 1);
		} finally { DebugExitRule(GrammarFileName, "expressionSequence"); }
		return r;

	}
	// $ANTLR end "expressionSequence"


	partial void EnterRule_expressionList();
	partial void LeaveRule_expressionList();

	// $ANTLR start "expressionList"
	// Tiger.g3:234:1: expressionList returns [ExpressionList r] : a= expression ( Comma b= expression )* ;
	[GrammarRule("expressionList")]
	private ExpressionList expressionList()
	{
		EnterRule_expressionList();
		EnterRule("expressionList", 10);
		TraceIn("expressionList", 10);
		ExpressionList r = default(ExpressionList);

		Expression a = default(Expression);
		Expression b = default(Expression);


			ExpressionList t = null;

		try { DebugEnterRule(GrammarFileName, "expressionList");
		DebugLocation(234, 1);
		try
		{
			// Tiger.g3:239:2: (a= expression ( Comma b= expression )* )
			DebugEnterAlt(1);
			// Tiger.g3:239:4: a= expression ( Comma b= expression )*
			{
			DebugLocation(239, 6);
			PushFollow(Follow._expression_in_expressionList830);
			a=expression();
			PopFollow();
			if (state.failed) return r;
			DebugLocation(240, 3);
			if (state.backtracking == 0)
			{

							r = new ExpressionList(a, null);
							t = r;
						
			}
			DebugLocation(244, 3);
			// Tiger.g3:244:3: ( Comma b= expression )*
			try { DebugEnterSubRule(15);
			while (true)
			{
				int alt15=2;
				try { DebugEnterDecision(15, false);
				int LA15_0 = input.LA(1);

				if ((LA15_0==Comma))
				{
					alt15 = 1;
				}


				} finally { DebugExitDecision(15); }
				switch ( alt15 )
				{
				case 1:
					DebugEnterAlt(1);
					// Tiger.g3:244:4: Comma b= expression
					{
					DebugLocation(244, 4);
					Match(input,Comma,Follow._Comma_in_expressionList839); if (state.failed) return r;
					DebugLocation(244, 12);
					PushFollow(Follow._expression_in_expressionList845);
					b=expression();
					PopFollow();
					if (state.failed) return r;
					DebugLocation(245, 3);
					if (state.backtracking == 0)
					{

									t.Tail = new ExpressionList(b, null);
									t = t.Tail;
								
					}

					}
					break;

				default:
					goto loop15;
				}
			}

			loop15:
				;

			} finally { DebugExitSubRule(15); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expressionList", 10);
			LeaveRule("expressionList", 10);
			LeaveRule_expressionList();
		}
		DebugLocation(250, 1);
		} finally { DebugExitRule(GrammarFileName, "expressionList"); }
		return r;

	}
	// $ANTLR end "expressionList"


	partial void EnterRule_fieldList();
	partial void LeaveRule_fieldList();

	// $ANTLR start "fieldList"
	// Tiger.g3:252:1: fieldList returns [FieldExpressionList r] : a= field ( Comma b= field )* ;
	[GrammarRule("fieldList")]
	private FieldExpressionList fieldList()
	{
		EnterRule_fieldList();
		EnterRule("fieldList", 11);
		TraceIn("fieldList", 11);
		FieldExpressionList r = default(FieldExpressionList);

		FieldExpressionList a = default(FieldExpressionList);
		FieldExpressionList b = default(FieldExpressionList);


			FieldExpressionList t = null;

		try { DebugEnterRule(GrammarFileName, "fieldList");
		DebugLocation(252, 1);
		try
		{
			// Tiger.g3:257:2: (a= field ( Comma b= field )* )
			DebugEnterAlt(1);
			// Tiger.g3:257:4: a= field ( Comma b= field )*
			{
			DebugLocation(257, 6);
			PushFollow(Follow._field_in_fieldList879);
			a=field();
			PopFollow();
			if (state.failed) return r;
			DebugLocation(258, 3);
			if (state.backtracking == 0)
			{

							r = a;
							t = r;
						
			}
			DebugLocation(262, 3);
			// Tiger.g3:262:3: ( Comma b= field )*
			try { DebugEnterSubRule(16);
			while (true)
			{
				int alt16=2;
				try { DebugEnterDecision(16, false);
				int LA16_0 = input.LA(1);

				if ((LA16_0==Comma))
				{
					alt16 = 1;
				}


				} finally { DebugExitDecision(16); }
				switch ( alt16 )
				{
				case 1:
					DebugEnterAlt(1);
					// Tiger.g3:262:4: Comma b= field
					{
					DebugLocation(262, 4);
					Match(input,Comma,Follow._Comma_in_fieldList888); if (state.failed) return r;
					DebugLocation(262, 12);
					PushFollow(Follow._field_in_fieldList894);
					b=field();
					PopFollow();
					if (state.failed) return r;
					DebugLocation(263, 3);
					if (state.backtracking == 0)
					{

									t.Tail = b;
									t = t.Tail;
								
					}

					}
					break;

				default:
					goto loop16;
				}
			}

			loop16:
				;

			} finally { DebugExitSubRule(16); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("fieldList", 11);
			LeaveRule("fieldList", 11);
			LeaveRule_fieldList();
		}
		DebugLocation(268, 1);
		} finally { DebugExitRule(GrammarFileName, "fieldList"); }
		return r;

	}
	// $ANTLR end "fieldList"


	partial void EnterRule_field();
	partial void LeaveRule_field();

	// $ANTLR start "field"
	// Tiger.g3:270:1: field returns [FieldExpressionList r] : Identifier Equal expression ;
	[GrammarRule("field")]
	private FieldExpressionList field()
	{
		EnterRule_field();
		EnterRule("field", 12);
		TraceIn("field", 12);
		FieldExpressionList r = default(FieldExpressionList);

		CommonToken Identifier29 = default(CommonToken);
		Expression expression30 = default(Expression);

		try { DebugEnterRule(GrammarFileName, "field");
		DebugLocation(270, 1);
		try
		{
			// Tiger.g3:271:2: ( Identifier Equal expression )
			DebugEnterAlt(1);
			// Tiger.g3:271:4: Identifier Equal expression
			{
			DebugLocation(271, 4);
			Identifier29=(CommonToken)Match(input,Identifier,Follow._Identifier_in_field919); if (state.failed) return r;
			DebugLocation(271, 15);
			Match(input,Equal,Follow._Equal_in_field921); if (state.failed) return r;
			DebugLocation(271, 21);
			PushFollow(Follow._expression_in_field923);
			expression30=expression();
			PopFollow();
			if (state.failed) return r;
			DebugLocation(272, 3);
			if (state.backtracking == 0)
			{

							r = new FieldExpressionList(new Position(Identifier29), Symbol.GetSymbol(Identifier29.Text), expression30, null);
						
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("field", 12);
			LeaveRule("field", 12);
			LeaveRule_field();
		}
		DebugLocation(275, 1);
		} finally { DebugExitRule(GrammarFileName, "field"); }
		return r;

	}
	// $ANTLR end "field"

	private sealed partial class lvalue_return : ParserRuleReturnScope<CommonToken>
	{
		public Variable r;
		public Position p;
		public lvalue_return(TigerParser grammar) {OnCreated(grammar);}
		partial void OnCreated(TigerParser grammar);
	}

	partial void EnterRule_lvalue();
	partial void LeaveRule_lvalue();

	// $ANTLR start "lvalue"
	// Tiger.g3:277:1: lvalue returns [Variable r, Position p] : id1= Identifier ( Dot id2= Identifier | LeftBrack expression RightBrack )* ;
	[GrammarRule("lvalue")]
	private TigerParser.lvalue_return lvalue()
	{
		EnterRule_lvalue();
		EnterRule("lvalue", 13);
		TraceIn("lvalue", 13);
		TigerParser.lvalue_return retval = new TigerParser.lvalue_return(this);
		retval.Start = (CommonToken)input.LT(1);

		CommonToken id1 = default(CommonToken);
		CommonToken id2 = default(CommonToken);
		CommonToken LeftBrack31 = default(CommonToken);
		Expression expression32 = default(Expression);

		try { DebugEnterRule(GrammarFileName, "lvalue");
		DebugLocation(277, 1);
		try
		{
			// Tiger.g3:278:2: (id1= Identifier ( Dot id2= Identifier | LeftBrack expression RightBrack )* )
			DebugEnterAlt(1);
			// Tiger.g3:278:4: id1= Identifier ( Dot id2= Identifier | LeftBrack expression RightBrack )*
			{
			DebugLocation(278, 8);
			id1=(CommonToken)Match(input,Identifier,Follow._Identifier_in_lvalue947); if (state.failed) return retval;
			DebugLocation(279, 3);
			if (state.backtracking == 0)
			{

							retval.p = new Position(id1);
							retval.r = new SimpleVariable(new Position(id1), Symbol.GetSymbol(id1.Text));
						
			}
			DebugLocation(283, 3);
			// Tiger.g3:283:3: ( Dot id2= Identifier | LeftBrack expression RightBrack )*
			try { DebugEnterSubRule(17);
			while (true)
			{
				int alt17=3;
				try { DebugEnterDecision(17, false);
				int LA17_0 = input.LA(1);

				if ((LA17_0==Dot))
				{
					alt17 = 1;
				}
				else if ((LA17_0==LeftBrack))
				{
					alt17 = 2;
				}


				} finally { DebugExitDecision(17); }
				switch ( alt17 )
				{
				case 1:
					DebugEnterAlt(1);
					// Tiger.g3:284:4: Dot id2= Identifier
					{
					DebugLocation(284, 4);
					Match(input,Dot,Follow._Dot_in_lvalue960); if (state.failed) return retval;
					DebugLocation(284, 12);
					id2=(CommonToken)Match(input,Identifier,Follow._Identifier_in_lvalue966); if (state.failed) return retval;
					DebugLocation(285, 4);
					if (state.backtracking == 0)
					{

										retval.r = new FieldVariable(new Position(id2), retval.r, Symbol.GetSymbol(id2.Text));
									
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Tiger.g3:288:5: LeftBrack expression RightBrack
					{
					DebugLocation(288, 5);
					LeftBrack31=(CommonToken)Match(input,LeftBrack,Follow._LeftBrack_in_lvalue977); if (state.failed) return retval;
					DebugLocation(288, 15);
					PushFollow(Follow._expression_in_lvalue979);
					expression32=expression();
					PopFollow();
					if (state.failed) return retval;
					DebugLocation(288, 26);
					Match(input,RightBrack,Follow._RightBrack_in_lvalue981); if (state.failed) return retval;
					DebugLocation(289, 4);
					if (state.backtracking == 0)
					{

										retval.r = new SubscriptVariable(new Position(LeftBrack31), retval.r, expression32);
									
					}

					}
					break;

				default:
					goto loop17;
				}
			}

			loop17:
				;

			} finally { DebugExitSubRule(17); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("lvalue", 13);
			LeaveRule("lvalue", 13);
			LeaveRule_lvalue();
		}
		DebugLocation(293, 1);
		} finally { DebugExitRule(GrammarFileName, "lvalue"); }
		return retval;

	}
	// $ANTLR end "lvalue"


	partial void EnterRule_declarationList();
	partial void LeaveRule_declarationList();

	// $ANTLR start "declarationList"
	// Tiger.g3:295:1: declarationList returns [DeclarationList r] : ( declaration )+ ;
	[GrammarRule("declarationList")]
	private DeclarationList declarationList()
	{
		EnterRule_declarationList();
		EnterRule("declarationList", 14);
		TraceIn("declarationList", 14);
		DeclarationList r = default(DeclarationList);

		Declaration declaration33 = default(Declaration);


			DeclarationList t = null;

		try { DebugEnterRule(GrammarFileName, "declarationList");
		DebugLocation(295, 1);
		try
		{
			// Tiger.g3:300:2: ( ( declaration )+ )
			DebugEnterAlt(1);
			// Tiger.g3:300:4: ( declaration )+
			{
			DebugLocation(300, 4);
			// Tiger.g3:300:4: ( declaration )+
			int cnt18=0;
			try { DebugEnterSubRule(18);
			while (true)
			{
				int alt18=2;
				try { DebugEnterDecision(18, false);
				int LA18_0 = input.LA(1);

				if ((LA18_0==Function||(LA18_0>=Type && LA18_0<=Var)))
				{
					alt18 = 1;
				}


				} finally { DebugExitDecision(18); }
				switch (alt18)
				{
				case 1:
					DebugEnterAlt(1);
					// Tiger.g3:300:5: declaration
					{
					DebugLocation(300, 5);
					PushFollow(Follow._declaration_in_declarationList1012);
					declaration33=declaration();
					PopFollow();
					if (state.failed) return r;
					DebugLocation(301, 3);
					if (state.backtracking == 0)
					{

									if (t == null)
									{
										r = new DeclarationList(declaration33, null);
										t = r;
									}
									else
									{
										t.Tail = new DeclarationList(declaration33, null);
										t = t.Tail;
									}
								
					}

					}
					break;

				default:
					if (cnt18 >= 1)
						goto loop18;

					if (state.backtracking>0) {state.failed=true; return r;}
					EarlyExitException eee18 = new EarlyExitException( 18, input );
					DebugRecognitionException(eee18);
					throw eee18;
				}
				cnt18++;
			}
			loop18:
				;

			} finally { DebugExitSubRule(18); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("declarationList", 14);
			LeaveRule("declarationList", 14);
			LeaveRule_declarationList();
		}
		DebugLocation(314, 1);
		} finally { DebugExitRule(GrammarFileName, "declarationList"); }
		return r;

	}
	// $ANTLR end "declarationList"


	partial void EnterRule_declaration();
	partial void LeaveRule_declaration();

	// $ANTLR start "declaration"
	// Tiger.g3:316:1: declaration returns [Declaration r] : ( typeDeclarationList | variableDeclaration | functionDeclarationList );
	[GrammarRule("declaration")]
	private Declaration declaration()
	{
		EnterRule_declaration();
		EnterRule("declaration", 15);
		TraceIn("declaration", 15);
		Declaration r = default(Declaration);

		TypeDeclaration typeDeclarationList34 = default(TypeDeclaration);
		VariableDeclaration variableDeclaration35 = default(VariableDeclaration);
		FunctionDeclaration functionDeclarationList36 = default(FunctionDeclaration);

		try { DebugEnterRule(GrammarFileName, "declaration");
		DebugLocation(316, 1);
		try
		{
			// Tiger.g3:317:2: ( typeDeclarationList | variableDeclaration | functionDeclarationList )
			int alt19=3;
			try { DebugEnterDecision(19, false);
			switch (input.LA(1))
			{
			case Type:
				{
				alt19 = 1;
				}
				break;
			case Var:
				{
				alt19 = 2;
				}
				break;
			case Function:
				{
				alt19 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return r;}
					NoViableAltException nvae = new NoViableAltException("", 19, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(19); }
			switch (alt19)
			{
			case 1:
				DebugEnterAlt(1);
				// Tiger.g3:317:4: typeDeclarationList
				{
				DebugLocation(317, 4);
				PushFollow(Follow._typeDeclarationList_in_declaration1036);
				typeDeclarationList34=typeDeclarationList();
				PopFollow();
				if (state.failed) return r;
				DebugLocation(318, 3);
				if (state.backtracking == 0)
				{

								r = typeDeclarationList34;
							
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Tiger.g3:321:4: variableDeclaration
				{
				DebugLocation(321, 4);
				PushFollow(Follow._variableDeclaration_in_declaration1045);
				variableDeclaration35=variableDeclaration();
				PopFollow();
				if (state.failed) return r;
				DebugLocation(322, 3);
				if (state.backtracking == 0)
				{

								r = variableDeclaration35;
							
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Tiger.g3:325:4: functionDeclarationList
				{
				DebugLocation(325, 4);
				PushFollow(Follow._functionDeclarationList_in_declaration1054);
				functionDeclarationList36=functionDeclarationList();
				PopFollow();
				if (state.failed) return r;
				DebugLocation(326, 3);
				if (state.backtracking == 0)
				{

								r = functionDeclarationList36;
							
				}

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("declaration", 15);
			LeaveRule("declaration", 15);
			LeaveRule_declaration();
		}
		DebugLocation(329, 1);
		} finally { DebugExitRule(GrammarFileName, "declaration"); }
		return r;

	}
	// $ANTLR end "declaration"


	partial void EnterRule_typeDeclarationList();
	partial void LeaveRule_typeDeclarationList();

	// $ANTLR start "typeDeclarationList"
	// Tiger.g3:331:1: typeDeclarationList returns [TypeDeclaration r] : ( typeDeclaration )+ ;
	[GrammarRule("typeDeclarationList")]
	private TypeDeclaration typeDeclarationList()
	{
		EnterRule_typeDeclarationList();
		EnterRule("typeDeclarationList", 16);
		TraceIn("typeDeclarationList", 16);
		TypeDeclaration r = default(TypeDeclaration);

		TypeDeclaration typeDeclaration37 = default(TypeDeclaration);


			TypeDeclaration t = null;

		try { DebugEnterRule(GrammarFileName, "typeDeclarationList");
		DebugLocation(331, 1);
		try
		{
			// Tiger.g3:336:2: ( ( typeDeclaration )+ )
			DebugEnterAlt(1);
			// Tiger.g3:336:4: ( typeDeclaration )+
			{
			DebugLocation(336, 4);
			// Tiger.g3:336:4: ( typeDeclaration )+
			int cnt20=0;
			try { DebugEnterSubRule(20);
			while (true)
			{
				int alt20=2;
				try { DebugEnterDecision(20, false);
				int LA20_0 = input.LA(1);

				if ((LA20_0==Type))
				{
					alt20 = 1;
				}


				} finally { DebugExitDecision(20); }
				switch (alt20)
				{
				case 1:
					DebugEnterAlt(1);
					// Tiger.g3:336:5: typeDeclaration
					{
					DebugLocation(336, 5);
					PushFollow(Follow._typeDeclaration_in_typeDeclarationList1079);
					typeDeclaration37=typeDeclaration();
					PopFollow();
					if (state.failed) return r;
					DebugLocation(337, 3);
					if (state.backtracking == 0)
					{

									if (t == null)
									{
										r = typeDeclaration37;
										t = r;
									}
									else
									{
										t.Next = typeDeclaration37;
										t = t.Next;
									}
								
					}

					}
					break;

				default:
					if (cnt20 >= 1)
						goto loop20;

					if (state.backtracking>0) {state.failed=true; return r;}
					EarlyExitException eee20 = new EarlyExitException( 20, input );
					DebugRecognitionException(eee20);
					throw eee20;
				}
				cnt20++;
			}
			loop20:
				;

			} finally { DebugExitSubRule(20); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("typeDeclarationList", 16);
			LeaveRule("typeDeclarationList", 16);
			LeaveRule_typeDeclarationList();
		}
		DebugLocation(350, 1);
		} finally { DebugExitRule(GrammarFileName, "typeDeclarationList"); }
		return r;

	}
	// $ANTLR end "typeDeclarationList"


	partial void EnterRule_typeDeclaration();
	partial void LeaveRule_typeDeclaration();

	// $ANTLR start "typeDeclaration"
	// Tiger.g3:352:1: typeDeclaration returns [TypeDeclaration r] : Type Identifier Equal type ;
	[GrammarRule("typeDeclaration")]
	private TypeDeclaration typeDeclaration()
	{
		EnterRule_typeDeclaration();
		EnterRule("typeDeclaration", 17);
		TraceIn("typeDeclaration", 17);
		TypeDeclaration r = default(TypeDeclaration);

		CommonToken Type38 = default(CommonToken);
		CommonToken Identifier39 = default(CommonToken);
		Type type40 = default(Type);

		try { DebugEnterRule(GrammarFileName, "typeDeclaration");
		DebugLocation(352, 1);
		try
		{
			// Tiger.g3:353:2: ( Type Identifier Equal type )
			DebugEnterAlt(1);
			// Tiger.g3:353:4: Type Identifier Equal type
			{
			DebugLocation(353, 4);
			Type38=(CommonToken)Match(input,Type,Follow._Type_in_typeDeclaration1103); if (state.failed) return r;
			DebugLocation(353, 9);
			Identifier39=(CommonToken)Match(input,Identifier,Follow._Identifier_in_typeDeclaration1105); if (state.failed) return r;
			DebugLocation(353, 20);
			Match(input,Equal,Follow._Equal_in_typeDeclaration1107); if (state.failed) return r;
			DebugLocation(353, 26);
			PushFollow(Follow._type_in_typeDeclaration1109);
			type40=type();
			PopFollow();
			if (state.failed) return r;
			DebugLocation(354, 3);
			if (state.backtracking == 0)
			{

							r = new TypeDeclaration(new Position(Type38), Symbol.GetSymbol(Identifier39.Text), type40, null);
						
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("typeDeclaration", 17);
			LeaveRule("typeDeclaration", 17);
			LeaveRule_typeDeclaration();
		}
		DebugLocation(357, 1);
		} finally { DebugExitRule(GrammarFileName, "typeDeclaration"); }
		return r;

	}
	// $ANTLR end "typeDeclaration"


	partial void EnterRule_type();
	partial void LeaveRule_type();

	// $ANTLR start "type"
	// Tiger.g3:359:1: type returns [Type r] : ( Identifier | LeftBrace ( typeFieldList )? RightBrace | Array Of Identifier );
	[GrammarRule("type")]
	private Type type()
	{
		EnterRule_type();
		EnterRule("type", 18);
		TraceIn("type", 18);
		Type r = default(Type);

		CommonToken Identifier41 = default(CommonToken);
		CommonToken LeftBrace42 = default(CommonToken);
		CommonToken Array44 = default(CommonToken);
		CommonToken Identifier45 = default(CommonToken);
		FieldList typeFieldList43 = default(FieldList);


			bool flag = false;

		try { DebugEnterRule(GrammarFileName, "type");
		DebugLocation(359, 1);
		try
		{
			// Tiger.g3:364:2: ( Identifier | LeftBrace ( typeFieldList )? RightBrace | Array Of Identifier )
			int alt22=3;
			try { DebugEnterDecision(22, false);
			switch (input.LA(1))
			{
			case Identifier:
				{
				alt22 = 1;
				}
				break;
			case LeftBrace:
				{
				alt22 = 2;
				}
				break;
			case Array:
				{
				alt22 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return r;}
					NoViableAltException nvae = new NoViableAltException("", 22, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(22); }
			switch (alt22)
			{
			case 1:
				DebugEnterAlt(1);
				// Tiger.g3:364:4: Identifier
				{
				DebugLocation(364, 4);
				Identifier41=(CommonToken)Match(input,Identifier,Follow._Identifier_in_type1134); if (state.failed) return r;
				DebugLocation(365, 3);
				if (state.backtracking == 0)
				{

								r = new NameType(new Position(Identifier41), Symbol.GetSymbol(Identifier41.Text));
							
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Tiger.g3:368:4: LeftBrace ( typeFieldList )? RightBrace
				{
				DebugLocation(368, 4);
				LeftBrace42=(CommonToken)Match(input,LeftBrace,Follow._LeftBrace_in_type1144); if (state.failed) return r;
				DebugLocation(368, 14);
				// Tiger.g3:368:14: ( typeFieldList )?
				int alt21=2;
				try { DebugEnterSubRule(21);
				try { DebugEnterDecision(21, false);
				int LA21_0 = input.LA(1);

				if ((LA21_0==Identifier))
				{
					alt21 = 1;
				}
				} finally { DebugExitDecision(21); }
				switch (alt21)
				{
				case 1:
					DebugEnterAlt(1);
					// Tiger.g3:368:15: typeFieldList
					{
					DebugLocation(368, 15);
					PushFollow(Follow._typeFieldList_in_type1147);
					typeFieldList43=typeFieldList();
					PopFollow();
					if (state.failed) return r;
					DebugLocation(368, 29);
					if (state.backtracking == 0)
					{
						flag = true;
					}

					}
					break;

				}
				} finally { DebugExitSubRule(21); }

				DebugLocation(368, 46);
				Match(input,RightBrace,Follow._RightBrace_in_type1153); if (state.failed) return r;
				DebugLocation(369, 3);
				if (state.backtracking == 0)
				{

								r = new RecordType(new Position(LeftBrace42), flag ? typeFieldList43 : null);
							
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Tiger.g3:372:4: Array Of Identifier
				{
				DebugLocation(372, 4);
				Array44=(CommonToken)Match(input,Array,Follow._Array_in_type1163); if (state.failed) return r;
				DebugLocation(372, 10);
				Match(input,Of,Follow._Of_in_type1165); if (state.failed) return r;
				DebugLocation(372, 13);
				Identifier45=(CommonToken)Match(input,Identifier,Follow._Identifier_in_type1167); if (state.failed) return r;
				DebugLocation(373, 3);
				if (state.backtracking == 0)
				{

								r = new ArrayType(new Position(Array44), Symbol.GetSymbol(Identifier45.Text));
							
				}

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("type", 18);
			LeaveRule("type", 18);
			LeaveRule_type();
		}
		DebugLocation(376, 1);
		} finally { DebugExitRule(GrammarFileName, "type"); }
		return r;

	}
	// $ANTLR end "type"


	partial void EnterRule_typeFieldList();
	partial void LeaveRule_typeFieldList();

	// $ANTLR start "typeFieldList"
	// Tiger.g3:378:1: typeFieldList returns [FieldList r] : a= typeField ( Comma b= typeField )* ;
	[GrammarRule("typeFieldList")]
	private FieldList typeFieldList()
	{
		EnterRule_typeFieldList();
		EnterRule("typeFieldList", 19);
		TraceIn("typeFieldList", 19);
		FieldList r = default(FieldList);

		FieldList a = default(FieldList);
		FieldList b = default(FieldList);


			FieldList t = null;

		try { DebugEnterRule(GrammarFileName, "typeFieldList");
		DebugLocation(378, 1);
		try
		{
			// Tiger.g3:383:2: (a= typeField ( Comma b= typeField )* )
			DebugEnterAlt(1);
			// Tiger.g3:383:4: a= typeField ( Comma b= typeField )*
			{
			DebugLocation(383, 6);
			PushFollow(Follow._typeField_in_typeFieldList1196);
			a=typeField();
			PopFollow();
			if (state.failed) return r;
			DebugLocation(384, 3);
			if (state.backtracking == 0)
			{

							r = a;
							t = r;
						
			}
			DebugLocation(388, 3);
			// Tiger.g3:388:3: ( Comma b= typeField )*
			try { DebugEnterSubRule(23);
			while (true)
			{
				int alt23=2;
				try { DebugEnterDecision(23, false);
				int LA23_0 = input.LA(1);

				if ((LA23_0==Comma))
				{
					alt23 = 1;
				}


				} finally { DebugExitDecision(23); }
				switch ( alt23 )
				{
				case 1:
					DebugEnterAlt(1);
					// Tiger.g3:388:4: Comma b= typeField
					{
					DebugLocation(388, 4);
					Match(input,Comma,Follow._Comma_in_typeFieldList1205); if (state.failed) return r;
					DebugLocation(388, 12);
					PushFollow(Follow._typeField_in_typeFieldList1211);
					b=typeField();
					PopFollow();
					if (state.failed) return r;
					DebugLocation(389, 3);
					if (state.backtracking == 0)
					{

									t.Tail = b;
									t = t.Tail;
								
					}

					}
					break;

				default:
					goto loop23;
				}
			}

			loop23:
				;

			} finally { DebugExitSubRule(23); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("typeFieldList", 19);
			LeaveRule("typeFieldList", 19);
			LeaveRule_typeFieldList();
		}
		DebugLocation(394, 1);
		} finally { DebugExitRule(GrammarFileName, "typeFieldList"); }
		return r;

	}
	// $ANTLR end "typeFieldList"


	partial void EnterRule_typeField();
	partial void LeaveRule_typeField();

	// $ANTLR start "typeField"
	// Tiger.g3:396:1: typeField returns [FieldList r] : a= Identifier Colon b= Identifier ;
	[GrammarRule("typeField")]
	private FieldList typeField()
	{
		EnterRule_typeField();
		EnterRule("typeField", 20);
		TraceIn("typeField", 20);
		FieldList r = default(FieldList);

		CommonToken a = default(CommonToken);
		CommonToken b = default(CommonToken);

		try { DebugEnterRule(GrammarFileName, "typeField");
		DebugLocation(396, 1);
		try
		{
			// Tiger.g3:397:2: (a= Identifier Colon b= Identifier )
			DebugEnterAlt(1);
			// Tiger.g3:397:4: a= Identifier Colon b= Identifier
			{
			DebugLocation(397, 6);
			a=(CommonToken)Match(input,Identifier,Follow._Identifier_in_typeField1240); if (state.failed) return r;
			DebugLocation(397, 19);
			Match(input,Colon,Follow._Colon_in_typeField1242); if (state.failed) return r;
			DebugLocation(397, 27);
			b=(CommonToken)Match(input,Identifier,Follow._Identifier_in_typeField1248); if (state.failed) return r;
			DebugLocation(398, 3);
			if (state.backtracking == 0)
			{

							r = new FieldList(new Position(a), Symbol.GetSymbol(a.Text), Symbol.GetSymbol(b.Text), null);
						
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("typeField", 20);
			LeaveRule("typeField", 20);
			LeaveRule_typeField();
		}
		DebugLocation(401, 1);
		} finally { DebugExitRule(GrammarFileName, "typeField"); }
		return r;

	}
	// $ANTLR end "typeField"


	partial void EnterRule_variableDeclaration();
	partial void LeaveRule_variableDeclaration();

	// $ANTLR start "variableDeclaration"
	// Tiger.g3:403:1: variableDeclaration returns [VariableDeclaration r] : ( Var Identifier Assign expression | Var id= Identifier Colon ty= Identifier Assign expression );
	[GrammarRule("variableDeclaration")]
	private VariableDeclaration variableDeclaration()
	{
		EnterRule_variableDeclaration();
		EnterRule("variableDeclaration", 21);
		TraceIn("variableDeclaration", 21);
		VariableDeclaration r = default(VariableDeclaration);

		CommonToken id = default(CommonToken);
		CommonToken ty = default(CommonToken);
		CommonToken Var46 = default(CommonToken);
		CommonToken Identifier47 = default(CommonToken);
		CommonToken Var49 = default(CommonToken);
		Expression expression48 = default(Expression);
		Expression expression50 = default(Expression);

		try { DebugEnterRule(GrammarFileName, "variableDeclaration");
		DebugLocation(403, 1);
		try
		{
			// Tiger.g3:404:2: ( Var Identifier Assign expression | Var id= Identifier Colon ty= Identifier Assign expression )
			int alt24=2;
			try { DebugEnterDecision(24, false);
			int LA24_0 = input.LA(1);

			if ((LA24_0==Var))
			{
				int LA24_1 = input.LA(2);

				if ((LA24_1==Identifier))
				{
					int LA24_2 = input.LA(3);

					if ((LA24_2==Assign))
					{
						alt24 = 1;
					}
					else if ((LA24_2==Colon))
					{
						alt24 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return r;}
						NoViableAltException nvae = new NoViableAltException("", 24, 2, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return r;}
					NoViableAltException nvae = new NoViableAltException("", 24, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return r;}
				NoViableAltException nvae = new NoViableAltException("", 24, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(24); }
			switch (alt24)
			{
			case 1:
				DebugEnterAlt(1);
				// Tiger.g3:404:4: Var Identifier Assign expression
				{
				DebugLocation(404, 4);
				Var46=(CommonToken)Match(input,Var,Follow._Var_in_variableDeclaration1268); if (state.failed) return r;
				DebugLocation(404, 8);
				Identifier47=(CommonToken)Match(input,Identifier,Follow._Identifier_in_variableDeclaration1270); if (state.failed) return r;
				DebugLocation(404, 19);
				Match(input,Assign,Follow._Assign_in_variableDeclaration1272); if (state.failed) return r;
				DebugLocation(404, 26);
				PushFollow(Follow._expression_in_variableDeclaration1274);
				expression48=expression();
				PopFollow();
				if (state.failed) return r;
				DebugLocation(405, 3);
				if (state.backtracking == 0)
				{

								r = new VariableDeclaration(new Position(Var46), Symbol.GetSymbol(Identifier47.Text), null, expression48);
							
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Tiger.g3:408:4: Var id= Identifier Colon ty= Identifier Assign expression
				{
				DebugLocation(408, 4);
				Var49=(CommonToken)Match(input,Var,Follow._Var_in_variableDeclaration1284); if (state.failed) return r;
				DebugLocation(408, 11);
				id=(CommonToken)Match(input,Identifier,Follow._Identifier_in_variableDeclaration1290); if (state.failed) return r;
				DebugLocation(408, 24);
				Match(input,Colon,Follow._Colon_in_variableDeclaration1292); if (state.failed) return r;
				DebugLocation(408, 33);
				ty=(CommonToken)Match(input,Identifier,Follow._Identifier_in_variableDeclaration1298); if (state.failed) return r;
				DebugLocation(408, 46);
				Match(input,Assign,Follow._Assign_in_variableDeclaration1300); if (state.failed) return r;
				DebugLocation(408, 53);
				PushFollow(Follow._expression_in_variableDeclaration1302);
				expression50=expression();
				PopFollow();
				if (state.failed) return r;
				DebugLocation(409, 3);
				if (state.backtracking == 0)
				{

								r = new VariableDeclaration(new Position(Var49), Symbol.GetSymbol(id.Text), new NameType(new Position(ty), Symbol.GetSymbol(ty.Text)), expression50);
							
				}

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("variableDeclaration", 21);
			LeaveRule("variableDeclaration", 21);
			LeaveRule_variableDeclaration();
		}
		DebugLocation(412, 1);
		} finally { DebugExitRule(GrammarFileName, "variableDeclaration"); }
		return r;

	}
	// $ANTLR end "variableDeclaration"


	partial void EnterRule_functionDeclarationList();
	partial void LeaveRule_functionDeclarationList();

	// $ANTLR start "functionDeclarationList"
	// Tiger.g3:414:1: functionDeclarationList returns [FunctionDeclaration r] : ( functionDeclaration )+ ;
	[GrammarRule("functionDeclarationList")]
	private FunctionDeclaration functionDeclarationList()
	{
		EnterRule_functionDeclarationList();
		EnterRule("functionDeclarationList", 22);
		TraceIn("functionDeclarationList", 22);
		FunctionDeclaration r = default(FunctionDeclaration);

		FunctionDeclaration functionDeclaration51 = default(FunctionDeclaration);


			FunctionDeclaration t = null;

		try { DebugEnterRule(GrammarFileName, "functionDeclarationList");
		DebugLocation(414, 1);
		try
		{
			// Tiger.g3:419:2: ( ( functionDeclaration )+ )
			DebugEnterAlt(1);
			// Tiger.g3:419:4: ( functionDeclaration )+
			{
			DebugLocation(419, 4);
			// Tiger.g3:419:4: ( functionDeclaration )+
			int cnt25=0;
			try { DebugEnterSubRule(25);
			while (true)
			{
				int alt25=2;
				try { DebugEnterDecision(25, false);
				int LA25_0 = input.LA(1);

				if ((LA25_0==Function))
				{
					alt25 = 1;
				}


				} finally { DebugExitDecision(25); }
				switch (alt25)
				{
				case 1:
					DebugEnterAlt(1);
					// Tiger.g3:419:5: functionDeclaration
					{
					DebugLocation(419, 5);
					PushFollow(Follow._functionDeclaration_in_functionDeclarationList1328);
					functionDeclaration51=functionDeclaration();
					PopFollow();
					if (state.failed) return r;
					DebugLocation(420, 3);
					if (state.backtracking == 0)
					{

									if (t == null)
									{
										r = functionDeclaration51;
										t = r;
									}
									else
									{
										t.Next = functionDeclaration51;
										t = t.Next;
									}
								
					}

					}
					break;

				default:
					if (cnt25 >= 1)
						goto loop25;

					if (state.backtracking>0) {state.failed=true; return r;}
					EarlyExitException eee25 = new EarlyExitException( 25, input );
					DebugRecognitionException(eee25);
					throw eee25;
				}
				cnt25++;
			}
			loop25:
				;

			} finally { DebugExitSubRule(25); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("functionDeclarationList", 22);
			LeaveRule("functionDeclarationList", 22);
			LeaveRule_functionDeclarationList();
		}
		DebugLocation(433, 1);
		} finally { DebugExitRule(GrammarFileName, "functionDeclarationList"); }
		return r;

	}
	// $ANTLR end "functionDeclarationList"


	partial void EnterRule_functionDeclaration();
	partial void LeaveRule_functionDeclaration();

	// $ANTLR start "functionDeclaration"
	// Tiger.g3:434:1: functionDeclaration returns [FunctionDeclaration r] : ( Function Identifier LeftParen ( typeFieldList )? RightParen Equal expression | Function id1= Identifier LeftParen ( typeFieldList )? RightParen Colon id2= Identifier Equal expression );
	[GrammarRule("functionDeclaration")]
	private FunctionDeclaration functionDeclaration()
	{
		EnterRule_functionDeclaration();
		EnterRule("functionDeclaration", 23);
		TraceIn("functionDeclaration", 23);
		FunctionDeclaration r = default(FunctionDeclaration);

		CommonToken id1 = default(CommonToken);
		CommonToken id2 = default(CommonToken);
		CommonToken Function52 = default(CommonToken);
		CommonToken Identifier53 = default(CommonToken);
		CommonToken Function56 = default(CommonToken);
		FieldList typeFieldList54 = default(FieldList);
		Expression expression55 = default(Expression);
		FieldList typeFieldList57 = default(FieldList);
		Expression expression58 = default(Expression);

		try { DebugEnterRule(GrammarFileName, "functionDeclaration");
		DebugLocation(434, 1);
		try
		{
			// Tiger.g3:435:2: ( Function Identifier LeftParen ( typeFieldList )? RightParen Equal expression | Function id1= Identifier LeftParen ( typeFieldList )? RightParen Colon id2= Identifier Equal expression )
			int alt28=2;
			try { DebugEnterDecision(28, false);
			try
			{
				alt28 = dfa28.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(28); }
			switch (alt28)
			{
			case 1:
				DebugEnterAlt(1);
				// Tiger.g3:435:4: Function Identifier LeftParen ( typeFieldList )? RightParen Equal expression
				{
				DebugLocation(435, 4);
				Function52=(CommonToken)Match(input,Function,Follow._Function_in_functionDeclaration1351); if (state.failed) return r;
				DebugLocation(435, 13);
				Identifier53=(CommonToken)Match(input,Identifier,Follow._Identifier_in_functionDeclaration1353); if (state.failed) return r;
				DebugLocation(435, 24);
				Match(input,LeftParen,Follow._LeftParen_in_functionDeclaration1355); if (state.failed) return r;
				DebugLocation(435, 34);
				// Tiger.g3:435:34: ( typeFieldList )?
				int alt26=2;
				try { DebugEnterSubRule(26);
				try { DebugEnterDecision(26, false);
				int LA26_0 = input.LA(1);

				if ((LA26_0==Identifier))
				{
					alt26 = 1;
				}
				} finally { DebugExitDecision(26); }
				switch (alt26)
				{
				case 1:
					DebugEnterAlt(1);
					// Tiger.g3:435:34: typeFieldList
					{
					DebugLocation(435, 34);
					PushFollow(Follow._typeFieldList_in_functionDeclaration1357);
					typeFieldList54=typeFieldList();
					PopFollow();
					if (state.failed) return r;

					}
					break;

				}
				} finally { DebugExitSubRule(26); }

				DebugLocation(435, 49);
				Match(input,RightParen,Follow._RightParen_in_functionDeclaration1360); if (state.failed) return r;
				DebugLocation(435, 60);
				Match(input,Equal,Follow._Equal_in_functionDeclaration1362); if (state.failed) return r;
				DebugLocation(435, 66);
				PushFollow(Follow._expression_in_functionDeclaration1364);
				expression55=expression();
				PopFollow();
				if (state.failed) return r;
				DebugLocation(436, 3);
				if (state.backtracking == 0)
				{

								r = new FunctionDeclaration(new Position(Function52), Symbol.GetSymbol(Identifier53.Text), typeFieldList54, null, expression55, null);
							
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Tiger.g3:439:4: Function id1= Identifier LeftParen ( typeFieldList )? RightParen Colon id2= Identifier Equal expression
				{
				DebugLocation(439, 4);
				Function56=(CommonToken)Match(input,Function,Follow._Function_in_functionDeclaration1374); if (state.failed) return r;
				DebugLocation(439, 17);
				id1=(CommonToken)Match(input,Identifier,Follow._Identifier_in_functionDeclaration1380); if (state.failed) return r;
				DebugLocation(439, 30);
				Match(input,LeftParen,Follow._LeftParen_in_functionDeclaration1382); if (state.failed) return r;
				DebugLocation(439, 40);
				// Tiger.g3:439:40: ( typeFieldList )?
				int alt27=2;
				try { DebugEnterSubRule(27);
				try { DebugEnterDecision(27, false);
				int LA27_0 = input.LA(1);

				if ((LA27_0==Identifier))
				{
					alt27 = 1;
				}
				} finally { DebugExitDecision(27); }
				switch (alt27)
				{
				case 1:
					DebugEnterAlt(1);
					// Tiger.g3:439:40: typeFieldList
					{
					DebugLocation(439, 40);
					PushFollow(Follow._typeFieldList_in_functionDeclaration1384);
					typeFieldList57=typeFieldList();
					PopFollow();
					if (state.failed) return r;

					}
					break;

				}
				} finally { DebugExitSubRule(27); }

				DebugLocation(439, 55);
				Match(input,RightParen,Follow._RightParen_in_functionDeclaration1387); if (state.failed) return r;
				DebugLocation(439, 66);
				Match(input,Colon,Follow._Colon_in_functionDeclaration1389); if (state.failed) return r;
				DebugLocation(439, 76);
				id2=(CommonToken)Match(input,Identifier,Follow._Identifier_in_functionDeclaration1395); if (state.failed) return r;
				DebugLocation(439, 89);
				Match(input,Equal,Follow._Equal_in_functionDeclaration1397); if (state.failed) return r;
				DebugLocation(439, 95);
				PushFollow(Follow._expression_in_functionDeclaration1399);
				expression58=expression();
				PopFollow();
				if (state.failed) return r;
				DebugLocation(440, 3);
				if (state.backtracking == 0)
				{

								r = new FunctionDeclaration(new Position(Function56), Symbol.GetSymbol(id1.Text), typeFieldList57, new NameType(new Position(id2), Symbol.GetSymbol(id2.Text)), expression58, null);
							
				}

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("functionDeclaration", 23);
			LeaveRule("functionDeclaration", 23);
			LeaveRule_functionDeclaration();
		}
		DebugLocation(443, 1);
		} finally { DebugExitRule(GrammarFileName, "functionDeclaration"); }
		return r;

	}
	// $ANTLR end "functionDeclaration"

	partial void EnterRule_synpred5_Tiger_fragment();
	partial void LeaveRule_synpred5_Tiger_fragment();

	// $ANTLR start synpred5_Tiger
	public void synpred5_Tiger_fragment()
	{
		TigerParser.lvalue_return lvalue59 = default(TigerParser.lvalue_return);
		Expression expression60 = default(Expression);

		EnterRule_synpred5_Tiger_fragment();
		EnterRule("synpred5_Tiger_fragment", 28);
		TraceIn("synpred5_Tiger_fragment", 28);
		try
		{
			// Tiger.g3:161:4: ( lvalue Assign expression )
			DebugEnterAlt(1);
			// Tiger.g3:161:4: lvalue Assign expression
			{
			DebugLocation(161, 4);
			PushFollow(Follow._lvalue_in_synpred5_Tiger536);
			lvalue59=lvalue();
			PopFollow();
			if (state.failed) return;
			DebugLocation(161, 11);
			Match(input,Assign,Follow._Assign_in_synpred5_Tiger538); if (state.failed) return;
			DebugLocation(161, 18);
			PushFollow(Follow._expression_in_synpred5_Tiger540);
			expression60=expression();
			PopFollow();
			if (state.failed) return;
			DebugLocation(162, 3);
			if (state.backtracking == 0)
			{

							expressionAtom_stack.Peek().rr =  new AssignExpression((lvalue59!=null?lvalue59.p:default(Position)), (lvalue59!=null?lvalue59.r:default(Variable)), expression60);
						
			}

			}

		}
		finally
		{
			TraceOut("synpred5_Tiger_fragment", 28);
			LeaveRule("synpred5_Tiger_fragment", 28);
			LeaveRule_synpred5_Tiger_fragment();
		}
	}
	// $ANTLR end synpred5_Tiger

	partial void EnterRule_synpred6_Tiger_fragment();
	partial void LeaveRule_synpred6_Tiger_fragment();

	// $ANTLR start synpred6_Tiger
	public void synpred6_Tiger_fragment()
	{
		CommonToken Identifier61 = default(CommonToken);
		ExpressionList expressionList62 = default(ExpressionList);

		EnterRule_synpred6_Tiger_fragment();
		EnterRule("synpred6_Tiger_fragment", 29);
		TraceIn("synpred6_Tiger_fragment", 29);
		try
		{
			// Tiger.g3:165:4: ( Identifier LeftParen ( expressionList )? RightParen )
			DebugEnterAlt(1);
			// Tiger.g3:165:4: Identifier LeftParen ( expressionList )? RightParen
			{
			DebugLocation(165, 4);
			Identifier61=(CommonToken)Match(input,Identifier,Follow._Identifier_in_synpred6_Tiger550); if (state.failed) return;
			DebugLocation(165, 15);
			Match(input,LeftParen,Follow._LeftParen_in_synpred6_Tiger552); if (state.failed) return;
			DebugLocation(165, 25);
			// Tiger.g3:165:25: ( expressionList )?
			int alt29=2;
			try { DebugEnterSubRule(29);
			try { DebugEnterDecision(29, false);
			int LA29_0 = input.LA(1);

			if ((LA29_0==Break||LA29_0==For||(LA29_0>=Identifier && LA29_0<=If)||LA29_0==IntegerLiteral||LA29_0==LeftParen||LA29_0==Let||(LA29_0>=Minus && LA29_0<=Nil)||LA29_0==StringLiteral||LA29_0==While))
			{
				alt29 = 1;
			}
			} finally { DebugExitDecision(29); }
			switch (alt29)
			{
			case 1:
				DebugEnterAlt(1);
				// Tiger.g3:165:25: expressionList
				{
				DebugLocation(165, 25);
				PushFollow(Follow._expressionList_in_synpred6_Tiger554);
				expressionList62=expressionList();
				PopFollow();
				if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(29); }

			DebugLocation(165, 41);
			Match(input,RightParen,Follow._RightParen_in_synpred6_Tiger557); if (state.failed) return;
			DebugLocation(166, 3);
			if (state.backtracking == 0)
			{

							expressionAtom_stack.Peek().rr =  new CallExpression(new Position(Identifier61), Symbol.GetSymbol(Identifier61.Text), expressionList62);
						
			}

			}

		}
		finally
		{
			TraceOut("synpred6_Tiger_fragment", 29);
			LeaveRule("synpred6_Tiger_fragment", 29);
			LeaveRule_synpred6_Tiger_fragment();
		}
	}
	// $ANTLR end synpred6_Tiger

	partial void EnterRule_synpred8_Tiger_fragment();
	partial void LeaveRule_synpred8_Tiger_fragment();

	// $ANTLR start synpred8_Tiger
	public void synpred8_Tiger_fragment()
	{
		CommonToken Identifier63 = default(CommonToken);
		FieldExpressionList fieldList64 = default(FieldExpressionList);

		EnterRule_synpred8_Tiger_fragment();
		EnterRule("synpred8_Tiger_fragment", 31);
		TraceIn("synpred8_Tiger_fragment", 31);
		try
		{
			// Tiger.g3:173:4: ( Identifier LeftBrace fieldList RightBrace )
			DebugEnterAlt(1);
			// Tiger.g3:173:4: Identifier LeftBrace fieldList RightBrace
			{
			DebugLocation(173, 4);
			Identifier63=(CommonToken)Match(input,Identifier,Follow._Identifier_in_synpred8_Tiger582); if (state.failed) return;
			DebugLocation(173, 15);
			Match(input,LeftBrace,Follow._LeftBrace_in_synpred8_Tiger584); if (state.failed) return;
			DebugLocation(173, 25);
			PushFollow(Follow._fieldList_in_synpred8_Tiger586);
			fieldList64=fieldList();
			PopFollow();
			if (state.failed) return;
			DebugLocation(173, 35);
			Match(input,RightBrace,Follow._RightBrace_in_synpred8_Tiger588); if (state.failed) return;
			DebugLocation(174, 3);
			if (state.backtracking == 0)
			{

							expressionAtom_stack.Peek().rr =  new RecordExpression(new Position(Identifier63), Symbol.GetSymbol(Identifier63.Text), fieldList64);
						
			}

			}

		}
		finally
		{
			TraceOut("synpred8_Tiger_fragment", 31);
			LeaveRule("synpred8_Tiger_fragment", 31);
			LeaveRule_synpred8_Tiger_fragment();
		}
	}
	// $ANTLR end synpred8_Tiger

	partial void EnterRule_synpred9_Tiger_fragment();
	partial void LeaveRule_synpred9_Tiger_fragment();

	// $ANTLR start synpred9_Tiger
	public void synpred9_Tiger_fragment()
	{
		CommonToken Identifier65 = default(CommonToken);
		Expression size = default(Expression);
		Expression init = default(Expression);

		EnterRule_synpred9_Tiger_fragment();
		EnterRule("synpred9_Tiger_fragment", 32);
		TraceIn("synpred9_Tiger_fragment", 32);
		try
		{
			// Tiger.g3:177:4: ( Identifier LeftBrack size= expression RightBrack Of init= expression )
			DebugEnterAlt(1);
			// Tiger.g3:177:4: Identifier LeftBrack size= expression RightBrack Of init= expression
			{
			DebugLocation(177, 4);
			Identifier65=(CommonToken)Match(input,Identifier,Follow._Identifier_in_synpred9_Tiger598); if (state.failed) return;
			DebugLocation(177, 15);
			Match(input,LeftBrack,Follow._LeftBrack_in_synpred9_Tiger600); if (state.failed) return;
			DebugLocation(177, 30);
			PushFollow(Follow._expression_in_synpred9_Tiger606);
			size=expression();
			PopFollow();
			if (state.failed) return;
			DebugLocation(177, 43);
			Match(input,RightBrack,Follow._RightBrack_in_synpred9_Tiger608); if (state.failed) return;
			DebugLocation(177, 54);
			Match(input,Of,Follow._Of_in_synpred9_Tiger610); if (state.failed) return;
			DebugLocation(177, 62);
			PushFollow(Follow._expression_in_synpred9_Tiger616);
			init=expression();
			PopFollow();
			if (state.failed) return;
			DebugLocation(178, 3);
			if (state.backtracking == 0)
			{

							expressionAtom_stack.Peek().rr =  new ArrayExpression(new Position(Identifier65), Symbol.GetSymbol(Identifier65.Text), size, init);
						
			}

			}

		}
		finally
		{
			TraceOut("synpred9_Tiger_fragment", 32);
			LeaveRule("synpred9_Tiger_fragment", 32);
			LeaveRule_synpred9_Tiger_fragment();
		}
	}
	// $ANTLR end synpred9_Tiger
	#endregion Rules

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region DFA
	private DFA13 dfa13;
	private DFA28 dfa28;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa13 = new DFA13( this, SpecialStateTransition13 );
		dfa28 = new DFA28( this );
	}

	private class DFA13 : DFA
	{
		private const string DFA13_eotS =
			"\x11\xFFFF";
		private const string DFA13_eofS =
			"\x11\xFFFF";
		private const string DFA13_minS =
			"\x1\x8\x4\xFFFF\x1\x0\xB\xFFFF";
		private const string DFA13_maxS =
			"\x1\x30\x4\xFFFF\x1\x0\xB\xFFFF";
		private const string DFA13_acceptS =
			"\x1\xFFFF\x1\x1\x1\x2\x1\x3\x1\x4\x1\xFFFF\x1\x7\x1\xA\x1\xB\x1\xC\x1"+
			"\xD\x1\xE\x1\x5\x1\x6\x1\x8\x1\x9\x1\xF";
		private const string DFA13_specialS =
			"\x5\xFFFF\x1\x0\xB\xFFFF}>";
		private static readonly string[] DFA13_transitionS =
			{
				"\x1\xA\x8\xFFFF\x1\x9\x3\xFFFF\x1\x5\x1\x7\x1\xFFFF\x1\x2\x2\xFFFF\x1"+
				"\x6\x2\xFFFF\x1\xB\x1\xFFFF\x1\x4\x1\x3\x8\xFFFF\x1\x1\x5\xFFFF\x1\x8",
				"",
				"",
				"",
				"",
				"\x1\xFFFF",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA13_eot = DFA.UnpackEncodedString(DFA13_eotS);
		private static readonly short[] DFA13_eof = DFA.UnpackEncodedString(DFA13_eofS);
		private static readonly char[] DFA13_min = DFA.UnpackEncodedStringToUnsignedChars(DFA13_minS);
		private static readonly char[] DFA13_max = DFA.UnpackEncodedStringToUnsignedChars(DFA13_maxS);
		private static readonly short[] DFA13_accept = DFA.UnpackEncodedString(DFA13_acceptS);
		private static readonly short[] DFA13_special = DFA.UnpackEncodedString(DFA13_specialS);
		private static readonly short[][] DFA13_transition;

		static DFA13()
		{
			int numStates = DFA13_transitionS.Length;
			DFA13_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA13_transition[i] = DFA.UnpackEncodedString(DFA13_transitionS[i]);
			}
		}

		public DFA13( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
			: base(specialStateTransition)
		{
			this.recognizer = recognizer;
			this.decisionNumber = 13;
			this.eot = DFA13_eot;
			this.eof = DFA13_eof;
			this.min = DFA13_min;
			this.max = DFA13_max;
			this.accept = DFA13_accept;
			this.special = DFA13_special;
			this.transition = DFA13_transition;
		}

		public override string Description { get { return "124:1: expressionAtom returns [Expression r] options {backtrack=true; memoize=true; } : ( StringLiteral | IntegerLiteral | Nil | Minus expression | lvalue Assign expression | Identifier LeftParen ( expressionList )? RightParen | LeftParen ( expressionSequence )? RightParen | Identifier LeftBrace fieldList RightBrace | Identifier LeftBrack size= expression RightBrack Of init= expression | If test= expression Then then= expression ( Else els= expression )? | While test= expression Do body= expression | For Identifier Assign e= expression To high= expression Do body= expression | Break | Let declarationList In ( expressionSequence )? End | lvalue );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private int SpecialStateTransition13(DFA dfa, int s, IIntStream _input)
	{
		ITokenStream input = (ITokenStream)_input;
		int _s = s;
		switch (s)
		{
			case 0:
				int LA13_5 = input.LA(1);


				int index13_5 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred5_Tiger_fragment))) {s = 12;}

				else if ((EvaluatePredicate(synpred6_Tiger_fragment))) {s = 13;}

				else if ((EvaluatePredicate(synpred8_Tiger_fragment))) {s = 14;}

				else if ((EvaluatePredicate(synpred9_Tiger_fragment))) {s = 15;}

				else if ((true)) {s = 16;}


				input.Seek(index13_5);
				if (s >= 0) return s;
				break;
		}
		if (state.backtracking > 0) {state.failed=true; return -1;}
		NoViableAltException nvae = new NoViableAltException(dfa.Description, 13, _s, input);
		dfa.Error(nvae);
		throw nvae;
	}
	private class DFA28 : DFA
	{
		private const string DFA28_eotS =
			"\xE\xFFFF";
		private const string DFA28_eofS =
			"\xE\xFFFF";
		private const string DFA28_minS =
			"\x1\x12\x1\x15\x1\x1B\x1\x15\x2\x9\x1\x15\x2\xFFFF\x1\xA\x1\x15\x1\x9"+
			"\x1\x15\x1\xA";
		private const string DFA28_maxS =
			"\x1\x12\x1\x15\x1\x1B\x1\x28\x1\x9\x1\x10\x1\x15\x2\xFFFF\x1\x28\x1\x15"+
			"\x1\x9\x1\x15\x1\x28";
		private const string DFA28_acceptS =
			"\x7\xFFFF\x1\x1\x1\x2\x5\xFFFF";
		private const string DFA28_specialS =
			"\xE\xFFFF}>";
		private static readonly string[] DFA28_transitionS =
			{
				"\x1\x1",
				"\x1\x2",
				"\x1\x3",
				"\x1\x4\x12\xFFFF\x1\x5",
				"\x1\x6",
				"\x1\x8\x6\xFFFF\x1\x7",
				"\x1\x9",
				"",
				"",
				"\x1\xA\x1D\xFFFF\x1\x5",
				"\x1\xB",
				"\x1\xC",
				"\x1\xD",
				"\x1\xA\x1D\xFFFF\x1\x5"
			};

		private static readonly short[] DFA28_eot = DFA.UnpackEncodedString(DFA28_eotS);
		private static readonly short[] DFA28_eof = DFA.UnpackEncodedString(DFA28_eofS);
		private static readonly char[] DFA28_min = DFA.UnpackEncodedStringToUnsignedChars(DFA28_minS);
		private static readonly char[] DFA28_max = DFA.UnpackEncodedStringToUnsignedChars(DFA28_maxS);
		private static readonly short[] DFA28_accept = DFA.UnpackEncodedString(DFA28_acceptS);
		private static readonly short[] DFA28_special = DFA.UnpackEncodedString(DFA28_specialS);
		private static readonly short[][] DFA28_transition;

		static DFA28()
		{
			int numStates = DFA28_transitionS.Length;
			DFA28_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA28_transition[i] = DFA.UnpackEncodedString(DFA28_transitionS[i]);
			}
		}

		public DFA28( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 28;
			this.eot = DFA28_eot;
			this.eof = DFA28_eof;
			this.min = DFA28_min;
			this.max = DFA28_max;
			this.accept = DFA28_accept;
			this.special = DFA28_special;
			this.transition = DFA28_transition;
		}

		public override string Description { get { return "434:1: functionDeclaration returns [FunctionDeclaration r] : ( Function Identifier LeftParen ( typeFieldList )? RightParen Equal expression | Function id1= Identifier LeftParen ( typeFieldList )? RightParen Colon id2= Identifier Equal expression );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}


	#endregion DFA

	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _expression_in_program66 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _orExpression_in_expression85 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _andExpression_in_orExpression108 = new BitSet(new ulong[]{0x1000000002UL});
		public static readonly BitSet _Or_in_orExpression117 = new BitSet(new ulong[]{0x1040349620100UL});
		public static readonly BitSet _andExpression_in_orExpression123 = new BitSet(new ulong[]{0x1000000002UL});
		public static readonly BitSet _relationalExpression_in_andExpression152 = new BitSet(new ulong[]{0x12UL});
		public static readonly BitSet _And_in_andExpression161 = new BitSet(new ulong[]{0x1040349620100UL});
		public static readonly BitSet _relationalExpression_in_andExpression167 = new BitSet(new ulong[]{0x12UL});
		public static readonly BitSet _additiveExpression_in_relationalExpression200 = new BitSet(new ulong[]{0x430190002UL});
		public static readonly BitSet _Equal_in_relationalExpression218 = new BitSet(new ulong[]{0x1040349620100UL});
		public static readonly BitSet _NotEqual_in_relationalExpression230 = new BitSet(new ulong[]{0x1040349620100UL});
		public static readonly BitSet _LessThan_in_relationalExpression242 = new BitSet(new ulong[]{0x1040349620100UL});
		public static readonly BitSet _LessEqual_in_relationalExpression254 = new BitSet(new ulong[]{0x1040349620100UL});
		public static readonly BitSet _GreaterThan_in_relationalExpression266 = new BitSet(new ulong[]{0x1040349620100UL});
		public static readonly BitSet _GreaterEqual_in_relationalExpression278 = new BitSet(new ulong[]{0x1040349620100UL});
		public static readonly BitSet _additiveExpression_in_relationalExpression290 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _multiplicativeExpression_in_additiveExpression320 = new BitSet(new ulong[]{0x2100000002UL});
		public static readonly BitSet _Plus_in_additiveExpression338 = new BitSet(new ulong[]{0x1040349620100UL});
		public static readonly BitSet _Minus_in_additiveExpression350 = new BitSet(new ulong[]{0x1040349620100UL});
		public static readonly BitSet _multiplicativeExpression_in_additiveExpression362 = new BitSet(new ulong[]{0x2100000002UL});
		public static readonly BitSet _expressionAtom_in_multiplicativeExpression395 = new BitSet(new ulong[]{0x100000000802UL});
		public static readonly BitSet _Times_in_multiplicativeExpression413 = new BitSet(new ulong[]{0x1040349620100UL});
		public static readonly BitSet _Divide_in_multiplicativeExpression425 = new BitSet(new ulong[]{0x1040349620100UL});
		public static readonly BitSet _expressionAtom_in_multiplicativeExpression437 = new BitSet(new ulong[]{0x100000000802UL});
		public static readonly BitSet _StringLiteral_in_expressionAtom496 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IntegerLiteral_in_expressionAtom505 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Nil_in_expressionAtom515 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Minus_in_expressionAtom524 = new BitSet(new ulong[]{0x1040349620100UL});
		public static readonly BitSet _expression_in_expressionAtom526 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _lvalue_in_expressionAtom536 = new BitSet(new ulong[]{0x40UL});
		public static readonly BitSet _Assign_in_expressionAtom538 = new BitSet(new ulong[]{0x1040349620100UL});
		public static readonly BitSet _expression_in_expressionAtom540 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Identifier_in_expressionAtom550 = new BitSet(new ulong[]{0x8000000UL});
		public static readonly BitSet _LeftParen_in_expressionAtom552 = new BitSet(new ulong[]{0x1050349620100UL});
		public static readonly BitSet _expressionList_in_expressionAtom554 = new BitSet(new ulong[]{0x10000000000UL});
		public static readonly BitSet _RightParen_in_expressionAtom557 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LeftParen_in_expressionAtom567 = new BitSet(new ulong[]{0x1050349620100UL});
		public static readonly BitSet _expressionSequence_in_expressionAtom569 = new BitSet(new ulong[]{0x10000000000UL});
		public static readonly BitSet _RightParen_in_expressionAtom572 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Identifier_in_expressionAtom582 = new BitSet(new ulong[]{0x2000000UL});
		public static readonly BitSet _LeftBrace_in_expressionAtom584 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _fieldList_in_expressionAtom586 = new BitSet(new ulong[]{0x4000000000UL});
		public static readonly BitSet _RightBrace_in_expressionAtom588 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Identifier_in_expressionAtom598 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _LeftBrack_in_expressionAtom600 = new BitSet(new ulong[]{0x1040349620100UL});
		public static readonly BitSet _expression_in_expressionAtom606 = new BitSet(new ulong[]{0x8000000000UL});
		public static readonly BitSet _RightBrack_in_expressionAtom608 = new BitSet(new ulong[]{0x800000000UL});
		public static readonly BitSet _Of_in_expressionAtom610 = new BitSet(new ulong[]{0x1040349620100UL});
		public static readonly BitSet _expression_in_expressionAtom616 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _If_in_expressionAtom626 = new BitSet(new ulong[]{0x1040349620100UL});
		public static readonly BitSet _expression_in_expressionAtom632 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _Then_in_expressionAtom634 = new BitSet(new ulong[]{0x1040349620100UL});
		public static readonly BitSet _expression_in_expressionAtom640 = new BitSet(new ulong[]{0x4002UL});
		public static readonly BitSet _Else_in_expressionAtom643 = new BitSet(new ulong[]{0x1040349620100UL});
		public static readonly BitSet _expression_in_expressionAtom649 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _While_in_expressionAtom663 = new BitSet(new ulong[]{0x1040349620100UL});
		public static readonly BitSet _expression_in_expressionAtom669 = new BitSet(new ulong[]{0x1000UL});
		public static readonly BitSet _Do_in_expressionAtom671 = new BitSet(new ulong[]{0x1040349620100UL});
		public static readonly BitSet _expression_in_expressionAtom677 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _For_in_expressionAtom687 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _Identifier_in_expressionAtom689 = new BitSet(new ulong[]{0x40UL});
		public static readonly BitSet _Assign_in_expressionAtom691 = new BitSet(new ulong[]{0x1040349620100UL});
		public static readonly BitSet _expression_in_expressionAtom697 = new BitSet(new ulong[]{0x200000000000UL});
		public static readonly BitSet _To_in_expressionAtom699 = new BitSet(new ulong[]{0x1040349620100UL});
		public static readonly BitSet _expression_in_expressionAtom705 = new BitSet(new ulong[]{0x1000UL});
		public static readonly BitSet _Do_in_expressionAtom707 = new BitSet(new ulong[]{0x1040349620100UL});
		public static readonly BitSet _expression_in_expressionAtom713 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Break_in_expressionAtom723 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Let_in_expressionAtom733 = new BitSet(new ulong[]{0xC00000040000UL});
		public static readonly BitSet _declarationList_in_expressionAtom735 = new BitSet(new ulong[]{0x800000UL});
		public static readonly BitSet _In_in_expressionAtom737 = new BitSet(new ulong[]{0x1040349628100UL});
		public static readonly BitSet _expressionSequence_in_expressionAtom739 = new BitSet(new ulong[]{0x8000UL});
		public static readonly BitSet _End_in_expressionAtom742 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _lvalue_in_expressionAtom752 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expression_in_expressionSequence781 = new BitSet(new ulong[]{0x20000000002UL});
		public static readonly BitSet _Semicolon_in_expressionSequence790 = new BitSet(new ulong[]{0x1040349620100UL});
		public static readonly BitSet _expression_in_expressionSequence796 = new BitSet(new ulong[]{0x20000000002UL});
		public static readonly BitSet _expression_in_expressionList830 = new BitSet(new ulong[]{0x402UL});
		public static readonly BitSet _Comma_in_expressionList839 = new BitSet(new ulong[]{0x1040349620100UL});
		public static readonly BitSet _expression_in_expressionList845 = new BitSet(new ulong[]{0x402UL});
		public static readonly BitSet _field_in_fieldList879 = new BitSet(new ulong[]{0x402UL});
		public static readonly BitSet _Comma_in_fieldList888 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _field_in_fieldList894 = new BitSet(new ulong[]{0x402UL});
		public static readonly BitSet _Identifier_in_field919 = new BitSet(new ulong[]{0x10000UL});
		public static readonly BitSet _Equal_in_field921 = new BitSet(new ulong[]{0x1040349620100UL});
		public static readonly BitSet _expression_in_field923 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Identifier_in_lvalue947 = new BitSet(new ulong[]{0x4002002UL});
		public static readonly BitSet _Dot_in_lvalue960 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _Identifier_in_lvalue966 = new BitSet(new ulong[]{0x4002002UL});
		public static readonly BitSet _LeftBrack_in_lvalue977 = new BitSet(new ulong[]{0x1040349620100UL});
		public static readonly BitSet _expression_in_lvalue979 = new BitSet(new ulong[]{0x8000000000UL});
		public static readonly BitSet _RightBrack_in_lvalue981 = new BitSet(new ulong[]{0x4002002UL});
		public static readonly BitSet _declaration_in_declarationList1012 = new BitSet(new ulong[]{0xC00000040002UL});
		public static readonly BitSet _typeDeclarationList_in_declaration1036 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _variableDeclaration_in_declaration1045 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _functionDeclarationList_in_declaration1054 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _typeDeclaration_in_typeDeclarationList1079 = new BitSet(new ulong[]{0x400000000002UL});
		public static readonly BitSet _Type_in_typeDeclaration1103 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _Identifier_in_typeDeclaration1105 = new BitSet(new ulong[]{0x10000UL});
		public static readonly BitSet _Equal_in_typeDeclaration1107 = new BitSet(new ulong[]{0x2200020UL});
		public static readonly BitSet _type_in_typeDeclaration1109 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Identifier_in_type1134 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LeftBrace_in_type1144 = new BitSet(new ulong[]{0x4000200000UL});
		public static readonly BitSet _typeFieldList_in_type1147 = new BitSet(new ulong[]{0x4000000000UL});
		public static readonly BitSet _RightBrace_in_type1153 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Array_in_type1163 = new BitSet(new ulong[]{0x800000000UL});
		public static readonly BitSet _Of_in_type1165 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _Identifier_in_type1167 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _typeField_in_typeFieldList1196 = new BitSet(new ulong[]{0x402UL});
		public static readonly BitSet _Comma_in_typeFieldList1205 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _typeField_in_typeFieldList1211 = new BitSet(new ulong[]{0x402UL});
		public static readonly BitSet _Identifier_in_typeField1240 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _Colon_in_typeField1242 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _Identifier_in_typeField1248 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Var_in_variableDeclaration1268 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _Identifier_in_variableDeclaration1270 = new BitSet(new ulong[]{0x40UL});
		public static readonly BitSet _Assign_in_variableDeclaration1272 = new BitSet(new ulong[]{0x1040349620100UL});
		public static readonly BitSet _expression_in_variableDeclaration1274 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Var_in_variableDeclaration1284 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _Identifier_in_variableDeclaration1290 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _Colon_in_variableDeclaration1292 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _Identifier_in_variableDeclaration1298 = new BitSet(new ulong[]{0x40UL});
		public static readonly BitSet _Assign_in_variableDeclaration1300 = new BitSet(new ulong[]{0x1040349620100UL});
		public static readonly BitSet _expression_in_variableDeclaration1302 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _functionDeclaration_in_functionDeclarationList1328 = new BitSet(new ulong[]{0xC00000040002UL});
		public static readonly BitSet _Function_in_functionDeclaration1351 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _Identifier_in_functionDeclaration1353 = new BitSet(new ulong[]{0x8000000UL});
		public static readonly BitSet _LeftParen_in_functionDeclaration1355 = new BitSet(new ulong[]{0x10000200000UL});
		public static readonly BitSet _typeFieldList_in_functionDeclaration1357 = new BitSet(new ulong[]{0x10000000000UL});
		public static readonly BitSet _RightParen_in_functionDeclaration1360 = new BitSet(new ulong[]{0x10000UL});
		public static readonly BitSet _Equal_in_functionDeclaration1362 = new BitSet(new ulong[]{0x1040349620100UL});
		public static readonly BitSet _expression_in_functionDeclaration1364 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Function_in_functionDeclaration1374 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _Identifier_in_functionDeclaration1380 = new BitSet(new ulong[]{0x8000000UL});
		public static readonly BitSet _LeftParen_in_functionDeclaration1382 = new BitSet(new ulong[]{0x10000200000UL});
		public static readonly BitSet _typeFieldList_in_functionDeclaration1384 = new BitSet(new ulong[]{0x10000000000UL});
		public static readonly BitSet _RightParen_in_functionDeclaration1387 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _Colon_in_functionDeclaration1389 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _Identifier_in_functionDeclaration1395 = new BitSet(new ulong[]{0x10000UL});
		public static readonly BitSet _Equal_in_functionDeclaration1397 = new BitSet(new ulong[]{0x1040349620100UL});
		public static readonly BitSet _expression_in_functionDeclaration1399 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _lvalue_in_synpred5_Tiger536 = new BitSet(new ulong[]{0x40UL});
		public static readonly BitSet _Assign_in_synpred5_Tiger538 = new BitSet(new ulong[]{0x1040349620100UL});
		public static readonly BitSet _expression_in_synpred5_Tiger540 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Identifier_in_synpred6_Tiger550 = new BitSet(new ulong[]{0x8000000UL});
		public static readonly BitSet _LeftParen_in_synpred6_Tiger552 = new BitSet(new ulong[]{0x1050349620100UL});
		public static readonly BitSet _expressionList_in_synpred6_Tiger554 = new BitSet(new ulong[]{0x10000000000UL});
		public static readonly BitSet _RightParen_in_synpred6_Tiger557 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Identifier_in_synpred8_Tiger582 = new BitSet(new ulong[]{0x2000000UL});
		public static readonly BitSet _LeftBrace_in_synpred8_Tiger584 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _fieldList_in_synpred8_Tiger586 = new BitSet(new ulong[]{0x4000000000UL});
		public static readonly BitSet _RightBrace_in_synpred8_Tiger588 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Identifier_in_synpred9_Tiger598 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _LeftBrack_in_synpred9_Tiger600 = new BitSet(new ulong[]{0x1040349620100UL});
		public static readonly BitSet _expression_in_synpred9_Tiger606 = new BitSet(new ulong[]{0x8000000000UL});
		public static readonly BitSet _RightBrack_in_synpred9_Tiger608 = new BitSet(new ulong[]{0x800000000UL});
		public static readonly BitSet _Of_in_synpred9_Tiger610 = new BitSet(new ulong[]{0x1040349620100UL});
		public static readonly BitSet _expression_in_synpred9_Tiger616 = new BitSet(new ulong[]{0x2UL});

	}
	#endregion Follow sets
}

} // namespace NaiveTigerCompiler
