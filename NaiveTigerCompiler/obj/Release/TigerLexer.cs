//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.3.1.7705
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.3.1.7705 Tiger.g3 2011-06-17 13:56:34

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162


using System.Collections.Generic;
using Antlr.Runtime;

namespace NaiveTigerCompiler
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.3.1.7705")]
[System.CLSCompliant(false)]
public partial class TigerLexer : Antlr.Runtime.Lexer
{
	public const int EOF=-1;
	public const int And=4;
	public const int Array=5;
	public const int Assign=6;
	public const int BlockComment=7;
	public const int Break=8;
	public const int Colon=9;
	public const int Comma=10;
	public const int Divide=11;
	public const int Do=12;
	public const int Dot=13;
	public const int Else=14;
	public const int End=15;
	public const int Equal=16;
	public const int For=17;
	public const int Function=18;
	public const int GreaterEqual=19;
	public const int GreaterThan=20;
	public const int Identifier=21;
	public const int If=22;
	public const int In=23;
	public const int IntegerLiteral=24;
	public const int LeftBrace=25;
	public const int LeftBrack=26;
	public const int LeftParen=27;
	public const int LessEqual=28;
	public const int LessThan=29;
	public const int Let=30;
	public const int LineComment=31;
	public const int Minus=32;
	public const int Nil=33;
	public const int NotEqual=34;
	public const int Of=35;
	public const int Or=36;
	public const int Plus=37;
	public const int RightBrace=38;
	public const int RightBrack=39;
	public const int RightParen=40;
	public const int Semicolon=41;
	public const int StringLiteral=42;
	public const int Then=43;
	public const int Times=44;
	public const int To=45;
	public const int Type=46;
	public const int Var=47;
	public const int While=48;
	public const int WhiteSpace=49;

    // delegates
    // delegators

	public TigerLexer()
	{
		OnCreated();
	}

	public TigerLexer(ICharStream input )
		: this(input, new RecognizerSharedState())
	{
	}

	public TigerLexer(ICharStream input, RecognizerSharedState state)
		: base(input, state)
	{


		OnCreated();
	}
	public override string GrammarFileName { get { return "Tiger.g3"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	partial void EnterRule_Array();
	partial void LeaveRule_Array();

	// $ANTLR start "Array"
	[GrammarRule("Array")]
	private void mArray()
	{
		EnterRule_Array();
		EnterRule("Array", 1);
		TraceIn("Array", 1);
		try
		{
			int _type = Array;
			int _channel = DefaultTokenChannel;
			// Tiger.g3:450:6: ( 'array' )
			DebugEnterAlt(1);
			// Tiger.g3:450:7: 'array'
			{
			DebugLocation(450, 7);
			Match("array"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Array", 1);
			LeaveRule("Array", 1);
			LeaveRule_Array();
		}
	}
	// $ANTLR end "Array"

	partial void EnterRule_Break();
	partial void LeaveRule_Break();

	// $ANTLR start "Break"
	[GrammarRule("Break")]
	private void mBreak()
	{
		EnterRule_Break();
		EnterRule("Break", 2);
		TraceIn("Break", 2);
		try
		{
			int _type = Break;
			int _channel = DefaultTokenChannel;
			// Tiger.g3:451:6: ( 'break' )
			DebugEnterAlt(1);
			// Tiger.g3:451:7: 'break'
			{
			DebugLocation(451, 7);
			Match("break"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Break", 2);
			LeaveRule("Break", 2);
			LeaveRule_Break();
		}
	}
	// $ANTLR end "Break"

	partial void EnterRule_Do();
	partial void LeaveRule_Do();

	// $ANTLR start "Do"
	[GrammarRule("Do")]
	private void mDo()
	{
		EnterRule_Do();
		EnterRule("Do", 3);
		TraceIn("Do", 3);
		try
		{
			int _type = Do;
			int _channel = DefaultTokenChannel;
			// Tiger.g3:452:3: ( 'do' )
			DebugEnterAlt(1);
			// Tiger.g3:452:4: 'do'
			{
			DebugLocation(452, 4);
			Match("do"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Do", 3);
			LeaveRule("Do", 3);
			LeaveRule_Do();
		}
	}
	// $ANTLR end "Do"

	partial void EnterRule_Else();
	partial void LeaveRule_Else();

	// $ANTLR start "Else"
	[GrammarRule("Else")]
	private void mElse()
	{
		EnterRule_Else();
		EnterRule("Else", 4);
		TraceIn("Else", 4);
		try
		{
			int _type = Else;
			int _channel = DefaultTokenChannel;
			// Tiger.g3:453:5: ( 'else' )
			DebugEnterAlt(1);
			// Tiger.g3:453:6: 'else'
			{
			DebugLocation(453, 6);
			Match("else"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Else", 4);
			LeaveRule("Else", 4);
			LeaveRule_Else();
		}
	}
	// $ANTLR end "Else"

	partial void EnterRule_End();
	partial void LeaveRule_End();

	// $ANTLR start "End"
	[GrammarRule("End")]
	private void mEnd()
	{
		EnterRule_End();
		EnterRule("End", 5);
		TraceIn("End", 5);
		try
		{
			int _type = End;
			int _channel = DefaultTokenChannel;
			// Tiger.g3:454:4: ( 'end' )
			DebugEnterAlt(1);
			// Tiger.g3:454:5: 'end'
			{
			DebugLocation(454, 5);
			Match("end"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("End", 5);
			LeaveRule("End", 5);
			LeaveRule_End();
		}
	}
	// $ANTLR end "End"

	partial void EnterRule_For();
	partial void LeaveRule_For();

	// $ANTLR start "For"
	[GrammarRule("For")]
	private void mFor()
	{
		EnterRule_For();
		EnterRule("For", 6);
		TraceIn("For", 6);
		try
		{
			int _type = For;
			int _channel = DefaultTokenChannel;
			// Tiger.g3:455:4: ( 'for' )
			DebugEnterAlt(1);
			// Tiger.g3:455:5: 'for'
			{
			DebugLocation(455, 5);
			Match("for"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("For", 6);
			LeaveRule("For", 6);
			LeaveRule_For();
		}
	}
	// $ANTLR end "For"

	partial void EnterRule_Function();
	partial void LeaveRule_Function();

	// $ANTLR start "Function"
	[GrammarRule("Function")]
	private void mFunction()
	{
		EnterRule_Function();
		EnterRule("Function", 7);
		TraceIn("Function", 7);
		try
		{
			int _type = Function;
			int _channel = DefaultTokenChannel;
			// Tiger.g3:456:9: ( 'function' )
			DebugEnterAlt(1);
			// Tiger.g3:456:10: 'function'
			{
			DebugLocation(456, 10);
			Match("function"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Function", 7);
			LeaveRule("Function", 7);
			LeaveRule_Function();
		}
	}
	// $ANTLR end "Function"

	partial void EnterRule_If();
	partial void LeaveRule_If();

	// $ANTLR start "If"
	[GrammarRule("If")]
	private void mIf()
	{
		EnterRule_If();
		EnterRule("If", 8);
		TraceIn("If", 8);
		try
		{
			int _type = If;
			int _channel = DefaultTokenChannel;
			// Tiger.g3:457:3: ( 'if' )
			DebugEnterAlt(1);
			// Tiger.g3:457:4: 'if'
			{
			DebugLocation(457, 4);
			Match("if"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("If", 8);
			LeaveRule("If", 8);
			LeaveRule_If();
		}
	}
	// $ANTLR end "If"

	partial void EnterRule_In();
	partial void LeaveRule_In();

	// $ANTLR start "In"
	[GrammarRule("In")]
	private void mIn()
	{
		EnterRule_In();
		EnterRule("In", 9);
		TraceIn("In", 9);
		try
		{
			int _type = In;
			int _channel = DefaultTokenChannel;
			// Tiger.g3:458:3: ( 'in' )
			DebugEnterAlt(1);
			// Tiger.g3:458:4: 'in'
			{
			DebugLocation(458, 4);
			Match("in"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("In", 9);
			LeaveRule("In", 9);
			LeaveRule_In();
		}
	}
	// $ANTLR end "In"

	partial void EnterRule_Let();
	partial void LeaveRule_Let();

	// $ANTLR start "Let"
	[GrammarRule("Let")]
	private void mLet()
	{
		EnterRule_Let();
		EnterRule("Let", 10);
		TraceIn("Let", 10);
		try
		{
			int _type = Let;
			int _channel = DefaultTokenChannel;
			// Tiger.g3:459:4: ( 'let' )
			DebugEnterAlt(1);
			// Tiger.g3:459:5: 'let'
			{
			DebugLocation(459, 5);
			Match("let"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Let", 10);
			LeaveRule("Let", 10);
			LeaveRule_Let();
		}
	}
	// $ANTLR end "Let"

	partial void EnterRule_Nil();
	partial void LeaveRule_Nil();

	// $ANTLR start "Nil"
	[GrammarRule("Nil")]
	private void mNil()
	{
		EnterRule_Nil();
		EnterRule("Nil", 11);
		TraceIn("Nil", 11);
		try
		{
			int _type = Nil;
			int _channel = DefaultTokenChannel;
			// Tiger.g3:460:4: ( 'nil' )
			DebugEnterAlt(1);
			// Tiger.g3:460:5: 'nil'
			{
			DebugLocation(460, 5);
			Match("nil"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Nil", 11);
			LeaveRule("Nil", 11);
			LeaveRule_Nil();
		}
	}
	// $ANTLR end "Nil"

	partial void EnterRule_Of();
	partial void LeaveRule_Of();

	// $ANTLR start "Of"
	[GrammarRule("Of")]
	private void mOf()
	{
		EnterRule_Of();
		EnterRule("Of", 12);
		TraceIn("Of", 12);
		try
		{
			int _type = Of;
			int _channel = DefaultTokenChannel;
			// Tiger.g3:461:3: ( 'of' )
			DebugEnterAlt(1);
			// Tiger.g3:461:4: 'of'
			{
			DebugLocation(461, 4);
			Match("of"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Of", 12);
			LeaveRule("Of", 12);
			LeaveRule_Of();
		}
	}
	// $ANTLR end "Of"

	partial void EnterRule_Then();
	partial void LeaveRule_Then();

	// $ANTLR start "Then"
	[GrammarRule("Then")]
	private void mThen()
	{
		EnterRule_Then();
		EnterRule("Then", 13);
		TraceIn("Then", 13);
		try
		{
			int _type = Then;
			int _channel = DefaultTokenChannel;
			// Tiger.g3:462:5: ( 'then' )
			DebugEnterAlt(1);
			// Tiger.g3:462:6: 'then'
			{
			DebugLocation(462, 6);
			Match("then"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Then", 13);
			LeaveRule("Then", 13);
			LeaveRule_Then();
		}
	}
	// $ANTLR end "Then"

	partial void EnterRule_To();
	partial void LeaveRule_To();

	// $ANTLR start "To"
	[GrammarRule("To")]
	private void mTo()
	{
		EnterRule_To();
		EnterRule("To", 14);
		TraceIn("To", 14);
		try
		{
			int _type = To;
			int _channel = DefaultTokenChannel;
			// Tiger.g3:463:3: ( 'to' )
			DebugEnterAlt(1);
			// Tiger.g3:463:4: 'to'
			{
			DebugLocation(463, 4);
			Match("to"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("To", 14);
			LeaveRule("To", 14);
			LeaveRule_To();
		}
	}
	// $ANTLR end "To"

	partial void EnterRule_Type();
	partial void LeaveRule_Type();

	// $ANTLR start "Type"
	[GrammarRule("Type")]
	private void mType()
	{
		EnterRule_Type();
		EnterRule("Type", 15);
		TraceIn("Type", 15);
		try
		{
			int _type = Type;
			int _channel = DefaultTokenChannel;
			// Tiger.g3:464:5: ( 'type' )
			DebugEnterAlt(1);
			// Tiger.g3:464:6: 'type'
			{
			DebugLocation(464, 6);
			Match("type"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Type", 15);
			LeaveRule("Type", 15);
			LeaveRule_Type();
		}
	}
	// $ANTLR end "Type"

	partial void EnterRule_Var();
	partial void LeaveRule_Var();

	// $ANTLR start "Var"
	[GrammarRule("Var")]
	private void mVar()
	{
		EnterRule_Var();
		EnterRule("Var", 16);
		TraceIn("Var", 16);
		try
		{
			int _type = Var;
			int _channel = DefaultTokenChannel;
			// Tiger.g3:465:4: ( 'var' )
			DebugEnterAlt(1);
			// Tiger.g3:465:5: 'var'
			{
			DebugLocation(465, 5);
			Match("var"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Var", 16);
			LeaveRule("Var", 16);
			LeaveRule_Var();
		}
	}
	// $ANTLR end "Var"

	partial void EnterRule_While();
	partial void LeaveRule_While();

	// $ANTLR start "While"
	[GrammarRule("While")]
	private void mWhile()
	{
		EnterRule_While();
		EnterRule("While", 17);
		TraceIn("While", 17);
		try
		{
			int _type = While;
			int _channel = DefaultTokenChannel;
			// Tiger.g3:466:6: ( 'while' )
			DebugEnterAlt(1);
			// Tiger.g3:466:7: 'while'
			{
			DebugLocation(466, 7);
			Match("while"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("While", 17);
			LeaveRule("While", 17);
			LeaveRule_While();
		}
	}
	// $ANTLR end "While"

	partial void EnterRule_Comma();
	partial void LeaveRule_Comma();

	// $ANTLR start "Comma"
	[GrammarRule("Comma")]
	private void mComma()
	{
		EnterRule_Comma();
		EnterRule("Comma", 18);
		TraceIn("Comma", 18);
		try
		{
			int _type = Comma;
			int _channel = DefaultTokenChannel;
			// Tiger.g3:469:6: ( ',' )
			DebugEnterAlt(1);
			// Tiger.g3:469:7: ','
			{
			DebugLocation(469, 7);
			Match(','); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Comma", 18);
			LeaveRule("Comma", 18);
			LeaveRule_Comma();
		}
	}
	// $ANTLR end "Comma"

	partial void EnterRule_Colon();
	partial void LeaveRule_Colon();

	// $ANTLR start "Colon"
	[GrammarRule("Colon")]
	private void mColon()
	{
		EnterRule_Colon();
		EnterRule("Colon", 19);
		TraceIn("Colon", 19);
		try
		{
			int _type = Colon;
			int _channel = DefaultTokenChannel;
			// Tiger.g3:470:6: ( ':' )
			DebugEnterAlt(1);
			// Tiger.g3:470:7: ':'
			{
			DebugLocation(470, 7);
			Match(':'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Colon", 19);
			LeaveRule("Colon", 19);
			LeaveRule_Colon();
		}
	}
	// $ANTLR end "Colon"

	partial void EnterRule_Semicolon();
	partial void LeaveRule_Semicolon();

	// $ANTLR start "Semicolon"
	[GrammarRule("Semicolon")]
	private void mSemicolon()
	{
		EnterRule_Semicolon();
		EnterRule("Semicolon", 20);
		TraceIn("Semicolon", 20);
		try
		{
			int _type = Semicolon;
			int _channel = DefaultTokenChannel;
			// Tiger.g3:471:10: ( ';' )
			DebugEnterAlt(1);
			// Tiger.g3:471:11: ';'
			{
			DebugLocation(471, 11);
			Match(';'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Semicolon", 20);
			LeaveRule("Semicolon", 20);
			LeaveRule_Semicolon();
		}
	}
	// $ANTLR end "Semicolon"

	partial void EnterRule_LeftParen();
	partial void LeaveRule_LeftParen();

	// $ANTLR start "LeftParen"
	[GrammarRule("LeftParen")]
	private void mLeftParen()
	{
		EnterRule_LeftParen();
		EnterRule("LeftParen", 21);
		TraceIn("LeftParen", 21);
		try
		{
			int _type = LeftParen;
			int _channel = DefaultTokenChannel;
			// Tiger.g3:472:10: ( '(' )
			DebugEnterAlt(1);
			// Tiger.g3:472:11: '('
			{
			DebugLocation(472, 11);
			Match('('); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LeftParen", 21);
			LeaveRule("LeftParen", 21);
			LeaveRule_LeftParen();
		}
	}
	// $ANTLR end "LeftParen"

	partial void EnterRule_RightParen();
	partial void LeaveRule_RightParen();

	// $ANTLR start "RightParen"
	[GrammarRule("RightParen")]
	private void mRightParen()
	{
		EnterRule_RightParen();
		EnterRule("RightParen", 22);
		TraceIn("RightParen", 22);
		try
		{
			int _type = RightParen;
			int _channel = DefaultTokenChannel;
			// Tiger.g3:473:11: ( ')' )
			DebugEnterAlt(1);
			// Tiger.g3:473:12: ')'
			{
			DebugLocation(473, 12);
			Match(')'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("RightParen", 22);
			LeaveRule("RightParen", 22);
			LeaveRule_RightParen();
		}
	}
	// $ANTLR end "RightParen"

	partial void EnterRule_LeftBrack();
	partial void LeaveRule_LeftBrack();

	// $ANTLR start "LeftBrack"
	[GrammarRule("LeftBrack")]
	private void mLeftBrack()
	{
		EnterRule_LeftBrack();
		EnterRule("LeftBrack", 23);
		TraceIn("LeftBrack", 23);
		try
		{
			int _type = LeftBrack;
			int _channel = DefaultTokenChannel;
			// Tiger.g3:474:10: ( '[' )
			DebugEnterAlt(1);
			// Tiger.g3:474:11: '['
			{
			DebugLocation(474, 11);
			Match('['); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LeftBrack", 23);
			LeaveRule("LeftBrack", 23);
			LeaveRule_LeftBrack();
		}
	}
	// $ANTLR end "LeftBrack"

	partial void EnterRule_RightBrack();
	partial void LeaveRule_RightBrack();

	// $ANTLR start "RightBrack"
	[GrammarRule("RightBrack")]
	private void mRightBrack()
	{
		EnterRule_RightBrack();
		EnterRule("RightBrack", 24);
		TraceIn("RightBrack", 24);
		try
		{
			int _type = RightBrack;
			int _channel = DefaultTokenChannel;
			// Tiger.g3:475:11: ( ']' )
			DebugEnterAlt(1);
			// Tiger.g3:475:12: ']'
			{
			DebugLocation(475, 12);
			Match(']'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("RightBrack", 24);
			LeaveRule("RightBrack", 24);
			LeaveRule_RightBrack();
		}
	}
	// $ANTLR end "RightBrack"

	partial void EnterRule_LeftBrace();
	partial void LeaveRule_LeftBrace();

	// $ANTLR start "LeftBrace"
	[GrammarRule("LeftBrace")]
	private void mLeftBrace()
	{
		EnterRule_LeftBrace();
		EnterRule("LeftBrace", 25);
		TraceIn("LeftBrace", 25);
		try
		{
			int _type = LeftBrace;
			int _channel = DefaultTokenChannel;
			// Tiger.g3:476:10: ( '{' )
			DebugEnterAlt(1);
			// Tiger.g3:476:11: '{'
			{
			DebugLocation(476, 11);
			Match('{'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LeftBrace", 25);
			LeaveRule("LeftBrace", 25);
			LeaveRule_LeftBrace();
		}
	}
	// $ANTLR end "LeftBrace"

	partial void EnterRule_RightBrace();
	partial void LeaveRule_RightBrace();

	// $ANTLR start "RightBrace"
	[GrammarRule("RightBrace")]
	private void mRightBrace()
	{
		EnterRule_RightBrace();
		EnterRule("RightBrace", 26);
		TraceIn("RightBrace", 26);
		try
		{
			int _type = RightBrace;
			int _channel = DefaultTokenChannel;
			// Tiger.g3:477:11: ( '}' )
			DebugEnterAlt(1);
			// Tiger.g3:477:12: '}'
			{
			DebugLocation(477, 12);
			Match('}'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("RightBrace", 26);
			LeaveRule("RightBrace", 26);
			LeaveRule_RightBrace();
		}
	}
	// $ANTLR end "RightBrace"

	partial void EnterRule_Dot();
	partial void LeaveRule_Dot();

	// $ANTLR start "Dot"
	[GrammarRule("Dot")]
	private void mDot()
	{
		EnterRule_Dot();
		EnterRule("Dot", 27);
		TraceIn("Dot", 27);
		try
		{
			int _type = Dot;
			int _channel = DefaultTokenChannel;
			// Tiger.g3:478:4: ( '.' )
			DebugEnterAlt(1);
			// Tiger.g3:478:5: '.'
			{
			DebugLocation(478, 5);
			Match('.'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Dot", 27);
			LeaveRule("Dot", 27);
			LeaveRule_Dot();
		}
	}
	// $ANTLR end "Dot"

	partial void EnterRule_Plus();
	partial void LeaveRule_Plus();

	// $ANTLR start "Plus"
	[GrammarRule("Plus")]
	private void mPlus()
	{
		EnterRule_Plus();
		EnterRule("Plus", 28);
		TraceIn("Plus", 28);
		try
		{
			int _type = Plus;
			int _channel = DefaultTokenChannel;
			// Tiger.g3:479:5: ( '+' )
			DebugEnterAlt(1);
			// Tiger.g3:479:6: '+'
			{
			DebugLocation(479, 6);
			Match('+'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Plus", 28);
			LeaveRule("Plus", 28);
			LeaveRule_Plus();
		}
	}
	// $ANTLR end "Plus"

	partial void EnterRule_Minus();
	partial void LeaveRule_Minus();

	// $ANTLR start "Minus"
	[GrammarRule("Minus")]
	private void mMinus()
	{
		EnterRule_Minus();
		EnterRule("Minus", 29);
		TraceIn("Minus", 29);
		try
		{
			int _type = Minus;
			int _channel = DefaultTokenChannel;
			// Tiger.g3:480:6: ( '-' )
			DebugEnterAlt(1);
			// Tiger.g3:480:7: '-'
			{
			DebugLocation(480, 7);
			Match('-'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Minus", 29);
			LeaveRule("Minus", 29);
			LeaveRule_Minus();
		}
	}
	// $ANTLR end "Minus"

	partial void EnterRule_Times();
	partial void LeaveRule_Times();

	// $ANTLR start "Times"
	[GrammarRule("Times")]
	private void mTimes()
	{
		EnterRule_Times();
		EnterRule("Times", 30);
		TraceIn("Times", 30);
		try
		{
			int _type = Times;
			int _channel = DefaultTokenChannel;
			// Tiger.g3:481:6: ( '*' )
			DebugEnterAlt(1);
			// Tiger.g3:481:7: '*'
			{
			DebugLocation(481, 7);
			Match('*'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Times", 30);
			LeaveRule("Times", 30);
			LeaveRule_Times();
		}
	}
	// $ANTLR end "Times"

	partial void EnterRule_Divide();
	partial void LeaveRule_Divide();

	// $ANTLR start "Divide"
	[GrammarRule("Divide")]
	private void mDivide()
	{
		EnterRule_Divide();
		EnterRule("Divide", 31);
		TraceIn("Divide", 31);
		try
		{
			int _type = Divide;
			int _channel = DefaultTokenChannel;
			// Tiger.g3:482:7: ( '/' )
			DebugEnterAlt(1);
			// Tiger.g3:482:8: '/'
			{
			DebugLocation(482, 8);
			Match('/'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Divide", 31);
			LeaveRule("Divide", 31);
			LeaveRule_Divide();
		}
	}
	// $ANTLR end "Divide"

	partial void EnterRule_Equal();
	partial void LeaveRule_Equal();

	// $ANTLR start "Equal"
	[GrammarRule("Equal")]
	private void mEqual()
	{
		EnterRule_Equal();
		EnterRule("Equal", 32);
		TraceIn("Equal", 32);
		try
		{
			int _type = Equal;
			int _channel = DefaultTokenChannel;
			// Tiger.g3:483:6: ( '=' )
			DebugEnterAlt(1);
			// Tiger.g3:483:7: '='
			{
			DebugLocation(483, 7);
			Match('='); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Equal", 32);
			LeaveRule("Equal", 32);
			LeaveRule_Equal();
		}
	}
	// $ANTLR end "Equal"

	partial void EnterRule_NotEqual();
	partial void LeaveRule_NotEqual();

	// $ANTLR start "NotEqual"
	[GrammarRule("NotEqual")]
	private void mNotEqual()
	{
		EnterRule_NotEqual();
		EnterRule("NotEqual", 33);
		TraceIn("NotEqual", 33);
		try
		{
			int _type = NotEqual;
			int _channel = DefaultTokenChannel;
			// Tiger.g3:484:9: ( '<>' )
			DebugEnterAlt(1);
			// Tiger.g3:484:10: '<>'
			{
			DebugLocation(484, 10);
			Match("<>"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("NotEqual", 33);
			LeaveRule("NotEqual", 33);
			LeaveRule_NotEqual();
		}
	}
	// $ANTLR end "NotEqual"

	partial void EnterRule_LessThan();
	partial void LeaveRule_LessThan();

	// $ANTLR start "LessThan"
	[GrammarRule("LessThan")]
	private void mLessThan()
	{
		EnterRule_LessThan();
		EnterRule("LessThan", 34);
		TraceIn("LessThan", 34);
		try
		{
			int _type = LessThan;
			int _channel = DefaultTokenChannel;
			// Tiger.g3:485:9: ( '<' )
			DebugEnterAlt(1);
			// Tiger.g3:485:10: '<'
			{
			DebugLocation(485, 10);
			Match('<'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LessThan", 34);
			LeaveRule("LessThan", 34);
			LeaveRule_LessThan();
		}
	}
	// $ANTLR end "LessThan"

	partial void EnterRule_LessEqual();
	partial void LeaveRule_LessEqual();

	// $ANTLR start "LessEqual"
	[GrammarRule("LessEqual")]
	private void mLessEqual()
	{
		EnterRule_LessEqual();
		EnterRule("LessEqual", 35);
		TraceIn("LessEqual", 35);
		try
		{
			int _type = LessEqual;
			int _channel = DefaultTokenChannel;
			// Tiger.g3:486:10: ( '<=' )
			DebugEnterAlt(1);
			// Tiger.g3:486:11: '<='
			{
			DebugLocation(486, 11);
			Match("<="); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LessEqual", 35);
			LeaveRule("LessEqual", 35);
			LeaveRule_LessEqual();
		}
	}
	// $ANTLR end "LessEqual"

	partial void EnterRule_GreaterThan();
	partial void LeaveRule_GreaterThan();

	// $ANTLR start "GreaterThan"
	[GrammarRule("GreaterThan")]
	private void mGreaterThan()
	{
		EnterRule_GreaterThan();
		EnterRule("GreaterThan", 36);
		TraceIn("GreaterThan", 36);
		try
		{
			int _type = GreaterThan;
			int _channel = DefaultTokenChannel;
			// Tiger.g3:487:12: ( '>' )
			DebugEnterAlt(1);
			// Tiger.g3:487:13: '>'
			{
			DebugLocation(487, 13);
			Match('>'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("GreaterThan", 36);
			LeaveRule("GreaterThan", 36);
			LeaveRule_GreaterThan();
		}
	}
	// $ANTLR end "GreaterThan"

	partial void EnterRule_GreaterEqual();
	partial void LeaveRule_GreaterEqual();

	// $ANTLR start "GreaterEqual"
	[GrammarRule("GreaterEqual")]
	private void mGreaterEqual()
	{
		EnterRule_GreaterEqual();
		EnterRule("GreaterEqual", 37);
		TraceIn("GreaterEqual", 37);
		try
		{
			int _type = GreaterEqual;
			int _channel = DefaultTokenChannel;
			// Tiger.g3:488:13: ( '>=' )
			DebugEnterAlt(1);
			// Tiger.g3:488:14: '>='
			{
			DebugLocation(488, 14);
			Match(">="); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("GreaterEqual", 37);
			LeaveRule("GreaterEqual", 37);
			LeaveRule_GreaterEqual();
		}
	}
	// $ANTLR end "GreaterEqual"

	partial void EnterRule_And();
	partial void LeaveRule_And();

	// $ANTLR start "And"
	[GrammarRule("And")]
	private void mAnd()
	{
		EnterRule_And();
		EnterRule("And", 38);
		TraceIn("And", 38);
		try
		{
			int _type = And;
			int _channel = DefaultTokenChannel;
			// Tiger.g3:489:4: ( '&' )
			DebugEnterAlt(1);
			// Tiger.g3:489:5: '&'
			{
			DebugLocation(489, 5);
			Match('&'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("And", 38);
			LeaveRule("And", 38);
			LeaveRule_And();
		}
	}
	// $ANTLR end "And"

	partial void EnterRule_Or();
	partial void LeaveRule_Or();

	// $ANTLR start "Or"
	[GrammarRule("Or")]
	private void mOr()
	{
		EnterRule_Or();
		EnterRule("Or", 39);
		TraceIn("Or", 39);
		try
		{
			int _type = Or;
			int _channel = DefaultTokenChannel;
			// Tiger.g3:490:3: ( '|' )
			DebugEnterAlt(1);
			// Tiger.g3:490:4: '|'
			{
			DebugLocation(490, 4);
			Match('|'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Or", 39);
			LeaveRule("Or", 39);
			LeaveRule_Or();
		}
	}
	// $ANTLR end "Or"

	partial void EnterRule_Assign();
	partial void LeaveRule_Assign();

	// $ANTLR start "Assign"
	[GrammarRule("Assign")]
	private void mAssign()
	{
		EnterRule_Assign();
		EnterRule("Assign", 40);
		TraceIn("Assign", 40);
		try
		{
			int _type = Assign;
			int _channel = DefaultTokenChannel;
			// Tiger.g3:491:7: ( ':=' )
			DebugEnterAlt(1);
			// Tiger.g3:491:8: ':='
			{
			DebugLocation(491, 8);
			Match(":="); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Assign", 40);
			LeaveRule("Assign", 40);
			LeaveRule_Assign();
		}
	}
	// $ANTLR end "Assign"

	partial void EnterRule_Identifier();
	partial void LeaveRule_Identifier();

	// $ANTLR start "Identifier"
	[GrammarRule("Identifier")]
	private void mIdentifier()
	{
		EnterRule_Identifier();
		EnterRule("Identifier", 41);
		TraceIn("Identifier", 41);
		try
		{
			int _type = Identifier;
			int _channel = DefaultTokenChannel;
			// Tiger.g3:494:11: ( ( 'a' .. 'z' | 'A' .. 'Z' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' )* )
			DebugEnterAlt(1);
			// Tiger.g3:494:12: ( 'a' .. 'z' | 'A' .. 'Z' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' )*
			{
			DebugLocation(494, 12);
			if ((input.LA(1)>='A' && input.LA(1)<='Z')||(input.LA(1)>='a' && input.LA(1)<='z'))
			{
				input.Consume();

			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;}

			DebugLocation(494, 33);
			// Tiger.g3:494:33: ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if (((LA1_0>='0' && LA1_0<='9')||(LA1_0>='A' && LA1_0<='Z')||LA1_0=='_'||(LA1_0>='a' && LA1_0<='z')))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// Tiger.g3:
					{
					DebugLocation(494, 33);
					input.Consume();


					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Identifier", 41);
			LeaveRule("Identifier", 41);
			LeaveRule_Identifier();
		}
	}
	// $ANTLR end "Identifier"

	partial void EnterRule_IntegerLiteral();
	partial void LeaveRule_IntegerLiteral();

	// $ANTLR start "IntegerLiteral"
	[GrammarRule("IntegerLiteral")]
	private void mIntegerLiteral()
	{
		EnterRule_IntegerLiteral();
		EnterRule("IntegerLiteral", 42);
		TraceIn("IntegerLiteral", 42);
		try
		{
			int _type = IntegerLiteral;
			int _channel = DefaultTokenChannel;
			// Tiger.g3:496:15: ( ( '0' .. '9' )+ )
			DebugEnterAlt(1);
			// Tiger.g3:496:16: ( '0' .. '9' )+
			{
			DebugLocation(496, 16);
			// Tiger.g3:496:16: ( '0' .. '9' )+
			int cnt2=0;
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, false);
				int LA2_0 = input.LA(1);

				if (((LA2_0>='0' && LA2_0<='9')))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch (alt2)
				{
				case 1:
					DebugEnterAlt(1);
					// Tiger.g3:
					{
					DebugLocation(496, 16);
					input.Consume();


					}
					break;

				default:
					if (cnt2 >= 1)
						goto loop2;

					EarlyExitException eee2 = new EarlyExitException( 2, input );
					DebugRecognitionException(eee2);
					throw eee2;
				}
				cnt2++;
			}
			loop2:
				;

			} finally { DebugExitSubRule(2); }


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("IntegerLiteral", 42);
			LeaveRule("IntegerLiteral", 42);
			LeaveRule_IntegerLiteral();
		}
	}
	// $ANTLR end "IntegerLiteral"

	partial void EnterRule_StringLiteral();
	partial void LeaveRule_StringLiteral();

	// $ANTLR start "StringLiteral"
	[GrammarRule("StringLiteral")]
	private void mStringLiteral()
	{
		EnterRule_StringLiteral();
		EnterRule("StringLiteral", 43);
		TraceIn("StringLiteral", 43);
		try
		{
			int _type = StringLiteral;
			int _channel = DefaultTokenChannel;
			int d1 = 0;
			int d2 = 0;
			int d3 = 0;
			int c = 0;


				System.Text.StringBuilder buffer = new System.Text.StringBuilder();

			// Tiger.g3:508:2: ( '\\\"' ( '\\\\' ( 't' | 'n' | 'r' | '\\\"' | '\\\\' | '^@' | '^A' | '^B' | '^C' | '^D' | '^E' | '^F' | '^G' | '^H' | '^I' | '^J' | '^K' | '^L' | '^M' | '^N' | '^O' | '^P' | '^Q' | '^R' | '^S' | '^T' | '^U' | '^V' | '^W' | '^X' | '^Y' | '^Z' | '^[' | '^\\\\' | '^]' | '^^' | '^_' |d1= ( '0' .. '2' ) d2= ( '0' .. '9' ) d3= ( '0' .. '9' ) ) | '\\\\' ( ' ' | '\\t' | '\\r' | '\\n' )+ '\\\\' |c=~ ( '\\\\' | '\\\"' ) )* '\\\"' )
			DebugEnterAlt(1);
			// Tiger.g3:508:4: '\\\"' ( '\\\\' ( 't' | 'n' | 'r' | '\\\"' | '\\\\' | '^@' | '^A' | '^B' | '^C' | '^D' | '^E' | '^F' | '^G' | '^H' | '^I' | '^J' | '^K' | '^L' | '^M' | '^N' | '^O' | '^P' | '^Q' | '^R' | '^S' | '^T' | '^U' | '^V' | '^W' | '^X' | '^Y' | '^Z' | '^[' | '^\\\\' | '^]' | '^^' | '^_' |d1= ( '0' .. '2' ) d2= ( '0' .. '9' ) d3= ( '0' .. '9' ) ) | '\\\\' ( ' ' | '\\t' | '\\r' | '\\n' )+ '\\\\' |c=~ ( '\\\\' | '\\\"' ) )* '\\\"'
			{
			DebugLocation(508, 4);
			Match('\"'); 
			DebugLocation(508, 9);
			// Tiger.g3:508:9: ( '\\\\' ( 't' | 'n' | 'r' | '\\\"' | '\\\\' | '^@' | '^A' | '^B' | '^C' | '^D' | '^E' | '^F' | '^G' | '^H' | '^I' | '^J' | '^K' | '^L' | '^M' | '^N' | '^O' | '^P' | '^Q' | '^R' | '^S' | '^T' | '^U' | '^V' | '^W' | '^X' | '^Y' | '^Z' | '^[' | '^\\\\' | '^]' | '^^' | '^_' |d1= ( '0' .. '2' ) d2= ( '0' .. '9' ) d3= ( '0' .. '9' ) ) | '\\\\' ( ' ' | '\\t' | '\\r' | '\\n' )+ '\\\\' |c=~ ( '\\\\' | '\\\"' ) )*
			try { DebugEnterSubRule(5);
			while (true)
			{
				int alt5=4;
				try { DebugEnterDecision(5, false);
				int LA5_0 = input.LA(1);

				if ((LA5_0=='\\'))
				{
					int LA5_2 = input.LA(2);

					if ((LA5_2=='\"'||(LA5_2>='0' && LA5_2<='2')||LA5_2=='\\'||LA5_2=='^'||LA5_2=='n'||LA5_2=='r'||LA5_2=='t'))
					{
						alt5 = 1;
					}
					else if (((LA5_2>='\t' && LA5_2<='\n')||LA5_2=='\r'||LA5_2==' '))
					{
						alt5 = 2;
					}


				}
				else if (((LA5_0>='\u0000' && LA5_0<='!')||(LA5_0>='#' && LA5_0<='[')||(LA5_0>=']' && LA5_0<='\uFFFF')))
				{
					alt5 = 3;
				}


				} finally { DebugExitDecision(5); }
				switch ( alt5 )
				{
				case 1:
					DebugEnterAlt(1);
					// Tiger.g3:509:3: '\\\\' ( 't' | 'n' | 'r' | '\\\"' | '\\\\' | '^@' | '^A' | '^B' | '^C' | '^D' | '^E' | '^F' | '^G' | '^H' | '^I' | '^J' | '^K' | '^L' | '^M' | '^N' | '^O' | '^P' | '^Q' | '^R' | '^S' | '^T' | '^U' | '^V' | '^W' | '^X' | '^Y' | '^Z' | '^[' | '^\\\\' | '^]' | '^^' | '^_' |d1= ( '0' .. '2' ) d2= ( '0' .. '9' ) d3= ( '0' .. '9' ) )
					{
					DebugLocation(509, 3);
					Match('\\'); 
					DebugLocation(509, 8);
					// Tiger.g3:509:8: ( 't' | 'n' | 'r' | '\\\"' | '\\\\' | '^@' | '^A' | '^B' | '^C' | '^D' | '^E' | '^F' | '^G' | '^H' | '^I' | '^J' | '^K' | '^L' | '^M' | '^N' | '^O' | '^P' | '^Q' | '^R' | '^S' | '^T' | '^U' | '^V' | '^W' | '^X' | '^Y' | '^Z' | '^[' | '^\\\\' | '^]' | '^^' | '^_' |d1= ( '0' .. '2' ) d2= ( '0' .. '9' ) d3= ( '0' .. '9' ) )
					int alt3=38;
					try { DebugEnterSubRule(3);
					try { DebugEnterDecision(3, false);
					try
					{
						alt3 = dfa3.Predict(input);
					}
					catch (NoViableAltException nvae)
					{
						DebugRecognitionException(nvae);
						throw;
					}
					} finally { DebugExitDecision(3); }
					switch (alt3)
					{
					case 1:
						DebugEnterAlt(1);
						// Tiger.g3:510:5: 't'
						{
						DebugLocation(510, 5);
						Match('t'); 
						DebugLocation(510, 9);
						buffer.Append('\t');

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// Tiger.g3:511:6: 'n'
						{
						DebugLocation(511, 6);
						Match('n'); 
						DebugLocation(511, 10);
						buffer.Append('\n');

						}
						break;
					case 3:
						DebugEnterAlt(3);
						// Tiger.g3:512:6: 'r'
						{
						DebugLocation(512, 6);
						Match('r'); 
						DebugLocation(512, 10);
						buffer.Append('\r');

						}
						break;
					case 4:
						DebugEnterAlt(4);
						// Tiger.g3:513:6: '\\\"'
						{
						DebugLocation(513, 6);
						Match('\"'); 
						DebugLocation(513, 11);
						buffer.Append('\"');

						}
						break;
					case 5:
						DebugEnterAlt(5);
						// Tiger.g3:514:6: '\\\\'
						{
						DebugLocation(514, 6);
						Match('\\'); 
						DebugLocation(514, 11);
						buffer.Append('\\');

						}
						break;
					case 6:
						DebugEnterAlt(6);
						// Tiger.g3:515:6: '^@'
						{
						DebugLocation(515, 6);
						Match("^@"); 

						DebugLocation(515, 11);
						buffer.Append('\0');

						}
						break;
					case 7:
						DebugEnterAlt(7);
						// Tiger.g3:516:6: '^A'
						{
						DebugLocation(516, 6);
						Match("^A"); 

						DebugLocation(516, 11);
						buffer.Append('\u0001');

						}
						break;
					case 8:
						DebugEnterAlt(8);
						// Tiger.g3:517:6: '^B'
						{
						DebugLocation(517, 6);
						Match("^B"); 

						DebugLocation(517, 11);
						buffer.Append('\u0002');

						}
						break;
					case 9:
						DebugEnterAlt(9);
						// Tiger.g3:518:6: '^C'
						{
						DebugLocation(518, 6);
						Match("^C"); 

						DebugLocation(518, 11);
						buffer.Append('\u0003');

						}
						break;
					case 10:
						DebugEnterAlt(10);
						// Tiger.g3:519:6: '^D'
						{
						DebugLocation(519, 6);
						Match("^D"); 

						DebugLocation(519, 11);
						buffer.Append('\u0004');

						}
						break;
					case 11:
						DebugEnterAlt(11);
						// Tiger.g3:520:6: '^E'
						{
						DebugLocation(520, 6);
						Match("^E"); 

						DebugLocation(520, 11);
						buffer.Append('\u0005');

						}
						break;
					case 12:
						DebugEnterAlt(12);
						// Tiger.g3:521:6: '^F'
						{
						DebugLocation(521, 6);
						Match("^F"); 

						DebugLocation(521, 11);
						buffer.Append('\u0006');

						}
						break;
					case 13:
						DebugEnterAlt(13);
						// Tiger.g3:522:6: '^G'
						{
						DebugLocation(522, 6);
						Match("^G"); 

						DebugLocation(522, 11);
						buffer.Append('\a');

						}
						break;
					case 14:
						DebugEnterAlt(14);
						// Tiger.g3:523:6: '^H'
						{
						DebugLocation(523, 6);
						Match("^H"); 

						DebugLocation(523, 11);
						buffer.Append('\b');

						}
						break;
					case 15:
						DebugEnterAlt(15);
						// Tiger.g3:524:6: '^I'
						{
						DebugLocation(524, 6);
						Match("^I"); 

						DebugLocation(524, 11);
						buffer.Append('\t');

						}
						break;
					case 16:
						DebugEnterAlt(16);
						// Tiger.g3:525:6: '^J'
						{
						DebugLocation(525, 6);
						Match("^J"); 

						DebugLocation(525, 11);
						buffer.Append('\n');

						}
						break;
					case 17:
						DebugEnterAlt(17);
						// Tiger.g3:526:6: '^K'
						{
						DebugLocation(526, 6);
						Match("^K"); 

						DebugLocation(526, 11);
						buffer.Append('\v');

						}
						break;
					case 18:
						DebugEnterAlt(18);
						// Tiger.g3:527:6: '^L'
						{
						DebugLocation(527, 6);
						Match("^L"); 

						DebugLocation(527, 11);
						buffer.Append('\f');

						}
						break;
					case 19:
						DebugEnterAlt(19);
						// Tiger.g3:528:6: '^M'
						{
						DebugLocation(528, 6);
						Match("^M"); 

						DebugLocation(528, 11);
						buffer.Append('\r');

						}
						break;
					case 20:
						DebugEnterAlt(20);
						// Tiger.g3:529:6: '^N'
						{
						DebugLocation(529, 6);
						Match("^N"); 

						DebugLocation(529, 11);
						buffer.Append('\u000E');

						}
						break;
					case 21:
						DebugEnterAlt(21);
						// Tiger.g3:530:6: '^O'
						{
						DebugLocation(530, 6);
						Match("^O"); 

						DebugLocation(530, 11);
						buffer.Append('\u000F');

						}
						break;
					case 22:
						DebugEnterAlt(22);
						// Tiger.g3:531:6: '^P'
						{
						DebugLocation(531, 6);
						Match("^P"); 

						DebugLocation(531, 11);
						buffer.Append('\u0010');

						}
						break;
					case 23:
						DebugEnterAlt(23);
						// Tiger.g3:532:6: '^Q'
						{
						DebugLocation(532, 6);
						Match("^Q"); 

						DebugLocation(532, 11);
						buffer.Append('\u0011');

						}
						break;
					case 24:
						DebugEnterAlt(24);
						// Tiger.g3:533:6: '^R'
						{
						DebugLocation(533, 6);
						Match("^R"); 

						DebugLocation(533, 11);
						buffer.Append('\u0012');

						}
						break;
					case 25:
						DebugEnterAlt(25);
						// Tiger.g3:534:6: '^S'
						{
						DebugLocation(534, 6);
						Match("^S"); 

						DebugLocation(534, 11);
						buffer.Append('\u0013');

						}
						break;
					case 26:
						DebugEnterAlt(26);
						// Tiger.g3:535:6: '^T'
						{
						DebugLocation(535, 6);
						Match("^T"); 

						DebugLocation(535, 11);
						buffer.Append('\u0014');

						}
						break;
					case 27:
						DebugEnterAlt(27);
						// Tiger.g3:536:6: '^U'
						{
						DebugLocation(536, 6);
						Match("^U"); 

						DebugLocation(536, 11);
						buffer.Append('\u0015');

						}
						break;
					case 28:
						DebugEnterAlt(28);
						// Tiger.g3:537:6: '^V'
						{
						DebugLocation(537, 6);
						Match("^V"); 

						DebugLocation(537, 11);
						buffer.Append('\u0016');

						}
						break;
					case 29:
						DebugEnterAlt(29);
						// Tiger.g3:538:6: '^W'
						{
						DebugLocation(538, 6);
						Match("^W"); 

						DebugLocation(538, 11);
						buffer.Append('\u0017');

						}
						break;
					case 30:
						DebugEnterAlt(30);
						// Tiger.g3:539:6: '^X'
						{
						DebugLocation(539, 6);
						Match("^X"); 

						DebugLocation(539, 11);
						buffer.Append('\u0018');

						}
						break;
					case 31:
						DebugEnterAlt(31);
						// Tiger.g3:540:6: '^Y'
						{
						DebugLocation(540, 6);
						Match("^Y"); 

						DebugLocation(540, 11);
						buffer.Append('\u0019');

						}
						break;
					case 32:
						DebugEnterAlt(32);
						// Tiger.g3:541:6: '^Z'
						{
						DebugLocation(541, 6);
						Match("^Z"); 

						DebugLocation(541, 11);
						buffer.Append('\u001A');

						}
						break;
					case 33:
						DebugEnterAlt(33);
						// Tiger.g3:542:6: '^['
						{
						DebugLocation(542, 6);
						Match("^["); 

						DebugLocation(542, 11);
						buffer.Append('\u001B');

						}
						break;
					case 34:
						DebugEnterAlt(34);
						// Tiger.g3:543:6: '^\\\\'
						{
						DebugLocation(543, 6);
						Match("^\\"); 

						DebugLocation(543, 12);
						buffer.Append('\u001C');

						}
						break;
					case 35:
						DebugEnterAlt(35);
						// Tiger.g3:544:6: '^]'
						{
						DebugLocation(544, 6);
						Match("^]"); 

						DebugLocation(544, 11);
						buffer.Append('\u001D');

						}
						break;
					case 36:
						DebugEnterAlt(36);
						// Tiger.g3:545:6: '^^'
						{
						DebugLocation(545, 6);
						Match("^^"); 

						DebugLocation(545, 11);
						buffer.Append('\u001E');

						}
						break;
					case 37:
						DebugEnterAlt(37);
						// Tiger.g3:546:6: '^_'
						{
						DebugLocation(546, 6);
						Match("^_"); 

						DebugLocation(546, 11);
						buffer.Append('\u001F');

						}
						break;
					case 38:
						DebugEnterAlt(38);
						// Tiger.g3:547:6: d1= ( '0' .. '2' ) d2= ( '0' .. '9' ) d3= ( '0' .. '9' )
						{
						DebugLocation(547, 9);
						d1= input.LA(1);
						input.Consume();

						DebugLocation(547, 25);
						d2= input.LA(1);
						input.Consume();

						DebugLocation(547, 41);
						d3= input.LA(1);
						input.Consume();

						DebugLocation(548, 5);

											int k = (d1 - '0') * 100 + (d2 - '0') * 10 + d3 - '0';
											if (k < 0 || k > 255)
											{
												throw new RecognitionException("escape character out of range", input);
											}
											buffer.Append((char)k);
										

						}
						break;

					}
					} finally { DebugExitSubRule(3); }


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Tiger.g3:557:5: '\\\\' ( ' ' | '\\t' | '\\r' | '\\n' )+ '\\\\'
					{
					DebugLocation(557, 5);
					Match('\\'); 
					DebugLocation(557, 10);
					// Tiger.g3:557:10: ( ' ' | '\\t' | '\\r' | '\\n' )+
					int cnt4=0;
					try { DebugEnterSubRule(4);
					while (true)
					{
						int alt4=2;
						try { DebugEnterDecision(4, false);
						int LA4_0 = input.LA(1);

						if (((LA4_0>='\t' && LA4_0<='\n')||LA4_0=='\r'||LA4_0==' '))
						{
							alt4 = 1;
						}


						} finally { DebugExitDecision(4); }
						switch (alt4)
						{
						case 1:
							DebugEnterAlt(1);
							// Tiger.g3:
							{
							DebugLocation(557, 10);
							input.Consume();


							}
							break;

						default:
							if (cnt4 >= 1)
								goto loop4;

							EarlyExitException eee4 = new EarlyExitException( 4, input );
							DebugRecognitionException(eee4);
							throw eee4;
						}
						cnt4++;
					}
					loop4:
						;

					} finally { DebugExitSubRule(4); }

					DebugLocation(557, 32);
					Match('\\'); 
					DebugLocation(558, 4);

									
								

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// Tiger.g3:561:5: c=~ ( '\\\\' | '\\\"' )
					{
					DebugLocation(561, 7);
					c= input.LA(1);
					input.Consume();

					DebugLocation(562, 4);

									buffer.Append((char)c);
								

					}
					break;

				default:
					goto loop5;
				}
			}

			loop5:
				;

			} finally { DebugExitSubRule(5); }

			DebugLocation(565, 6);
			Match('\"'); 

			}

			state.type = _type;
			state.channel = _channel;

				Text = buffer.ToString();
		}
		finally
		{
			TraceOut("StringLiteral", 43);
			LeaveRule("StringLiteral", 43);
			LeaveRule_StringLiteral();
		}
	}
	// $ANTLR end "StringLiteral"

	partial void EnterRule_WhiteSpace();
	partial void LeaveRule_WhiteSpace();

	// $ANTLR start "WhiteSpace"
	[GrammarRule("WhiteSpace")]
	private void mWhiteSpace()
	{
		EnterRule_WhiteSpace();
		EnterRule("WhiteSpace", 44);
		TraceIn("WhiteSpace", 44);
		try
		{
			int _type = WhiteSpace;
			int _channel = DefaultTokenChannel;
			// Tiger.g3:568:11: ( ( ' ' | '\\t' | '\\r' | '\\n' )+ )
			DebugEnterAlt(1);
			// Tiger.g3:568:12: ( ' ' | '\\t' | '\\r' | '\\n' )+
			{
			DebugLocation(568, 12);
			// Tiger.g3:568:12: ( ' ' | '\\t' | '\\r' | '\\n' )+
			int cnt6=0;
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=2;
				try { DebugEnterDecision(6, false);
				int LA6_0 = input.LA(1);

				if (((LA6_0>='\t' && LA6_0<='\n')||LA6_0=='\r'||LA6_0==' '))
				{
					alt6 = 1;
				}


				} finally { DebugExitDecision(6); }
				switch (alt6)
				{
				case 1:
					DebugEnterAlt(1);
					// Tiger.g3:
					{
					DebugLocation(568, 12);
					input.Consume();


					}
					break;

				default:
					if (cnt6 >= 1)
						goto loop6;

					EarlyExitException eee6 = new EarlyExitException( 6, input );
					DebugRecognitionException(eee6);
					throw eee6;
				}
				cnt6++;
			}
			loop6:
				;

			} finally { DebugExitSubRule(6); }

			DebugLocation(568, 34);
			 Skip(); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("WhiteSpace", 44);
			LeaveRule("WhiteSpace", 44);
			LeaveRule_WhiteSpace();
		}
	}
	// $ANTLR end "WhiteSpace"

	partial void EnterRule_BlockComment();
	partial void LeaveRule_BlockComment();

	// $ANTLR start "BlockComment"
	[GrammarRule("BlockComment")]
	private void mBlockComment()
	{
		EnterRule_BlockComment();
		EnterRule("BlockComment", 45);
		TraceIn("BlockComment", 45);
		try
		{
			int _type = BlockComment;
			int _channel = DefaultTokenChannel;
			// Tiger.g3:570:13: ( '/*' ( options {greedy=false; } : ( BlockComment | . ) )* '*/' )
			DebugEnterAlt(1);
			// Tiger.g3:570:14: '/*' ( options {greedy=false; } : ( BlockComment | . ) )* '*/'
			{
			DebugLocation(570, 14);
			Match("/*"); 

			DebugLocation(570, 19);
			// Tiger.g3:570:19: ( options {greedy=false; } : ( BlockComment | . ) )*
			try { DebugEnterSubRule(8);
			while (true)
			{
				int alt8=2;
				try { DebugEnterDecision(8, false);
				int LA8_0 = input.LA(1);

				if ((LA8_0=='*'))
				{
					int LA8_1 = input.LA(2);

					if ((LA8_1=='/'))
					{
						alt8 = 2;
					}
					else if (((LA8_1>='\u0000' && LA8_1<='.')||(LA8_1>='0' && LA8_1<='\uFFFF')))
					{
						alt8 = 1;
					}


				}
				else if (((LA8_0>='\u0000' && LA8_0<=')')||(LA8_0>='+' && LA8_0<='\uFFFF')))
				{
					alt8 = 1;
				}


				} finally { DebugExitDecision(8); }
				switch ( alt8 )
				{
				case 1:
					DebugEnterAlt(1);
					// Tiger.g3:570:51: ( BlockComment | . )
					{
					DebugLocation(570, 51);
					// Tiger.g3:570:51: ( BlockComment | . )
					int alt7=2;
					try { DebugEnterSubRule(7);
					try { DebugEnterDecision(7, false);
					int LA7_0 = input.LA(1);

					if ((LA7_0=='/'))
					{
						int LA7_1 = input.LA(2);

						if ((LA7_1=='*'))
						{
							alt7 = 1;
						}
						else if (((LA7_1>='\u0000' && LA7_1<=')')||(LA7_1>='+' && LA7_1<='\uFFFF')))
						{
							alt7 = 2;
						}
						else
						{
							NoViableAltException nvae = new NoViableAltException("", 7, 1, input);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}
					else if (((LA7_0>='\u0000' && LA7_0<='.')||(LA7_0>='0' && LA7_0<='\uFFFF')))
					{
						alt7 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 7, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(7); }
					switch (alt7)
					{
					case 1:
						DebugEnterAlt(1);
						// Tiger.g3:570:53: BlockComment
						{
						DebugLocation(570, 53);
						mBlockComment(); 

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// Tiger.g3:570:68: .
						{
						DebugLocation(570, 68);
						MatchAny(); 

						}
						break;

					}
					} finally { DebugExitSubRule(7); }


					}
					break;

				default:
					goto loop8;
				}
			}

			loop8:
				;

			} finally { DebugExitSubRule(8); }

			DebugLocation(570, 75);
			Match("*/"); 

			DebugLocation(570, 80);
			 Skip(); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("BlockComment", 45);
			LeaveRule("BlockComment", 45);
			LeaveRule_BlockComment();
		}
	}
	// $ANTLR end "BlockComment"

	partial void EnterRule_LineComment();
	partial void LeaveRule_LineComment();

	// $ANTLR start "LineComment"
	[GrammarRule("LineComment")]
	private void mLineComment()
	{
		EnterRule_LineComment();
		EnterRule("LineComment", 46);
		TraceIn("LineComment", 46);
		try
		{
			int _type = LineComment;
			int _channel = DefaultTokenChannel;
			// Tiger.g3:572:12: ( '//' (~ ( '\\n' | '\\r' ) )* )
			DebugEnterAlt(1);
			// Tiger.g3:572:14: '//' (~ ( '\\n' | '\\r' ) )*
			{
			DebugLocation(572, 14);
			Match("//"); 

			DebugLocation(572, 19);
			// Tiger.g3:572:19: (~ ( '\\n' | '\\r' ) )*
			try { DebugEnterSubRule(9);
			while (true)
			{
				int alt9=2;
				try { DebugEnterDecision(9, false);
				int LA9_0 = input.LA(1);

				if (((LA9_0>='\u0000' && LA9_0<='\t')||(LA9_0>='\u000B' && LA9_0<='\f')||(LA9_0>='\u000E' && LA9_0<='\uFFFF')))
				{
					alt9 = 1;
				}


				} finally { DebugExitDecision(9); }
				switch ( alt9 )
				{
				case 1:
					DebugEnterAlt(1);
					// Tiger.g3:
					{
					DebugLocation(572, 19);
					input.Consume();


					}
					break;

				default:
					goto loop9;
				}
			}

			loop9:
				;

			} finally { DebugExitSubRule(9); }

			DebugLocation(572, 33);
			 Skip(); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LineComment", 46);
			LeaveRule("LineComment", 46);
			LeaveRule_LineComment();
		}
	}
	// $ANTLR end "LineComment"

	public override void mTokens()
	{
		// Tiger.g3:1:8: ( Array | Break | Do | Else | End | For | Function | If | In | Let | Nil | Of | Then | To | Type | Var | While | Comma | Colon | Semicolon | LeftParen | RightParen | LeftBrack | RightBrack | LeftBrace | RightBrace | Dot | Plus | Minus | Times | Divide | Equal | NotEqual | LessThan | LessEqual | GreaterThan | GreaterEqual | And | Or | Assign | Identifier | IntegerLiteral | StringLiteral | WhiteSpace | BlockComment | LineComment )
		int alt10=46;
		try { DebugEnterDecision(10, false);
		try
		{
			alt10 = dfa10.Predict(input);
		}
		catch (NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
			throw;
		}
		} finally { DebugExitDecision(10); }
		switch (alt10)
		{
		case 1:
			DebugEnterAlt(1);
			// Tiger.g3:1:10: Array
			{
			DebugLocation(1, 10);
			mArray(); 

			}
			break;
		case 2:
			DebugEnterAlt(2);
			// Tiger.g3:1:16: Break
			{
			DebugLocation(1, 16);
			mBreak(); 

			}
			break;
		case 3:
			DebugEnterAlt(3);
			// Tiger.g3:1:22: Do
			{
			DebugLocation(1, 22);
			mDo(); 

			}
			break;
		case 4:
			DebugEnterAlt(4);
			// Tiger.g3:1:25: Else
			{
			DebugLocation(1, 25);
			mElse(); 

			}
			break;
		case 5:
			DebugEnterAlt(5);
			// Tiger.g3:1:30: End
			{
			DebugLocation(1, 30);
			mEnd(); 

			}
			break;
		case 6:
			DebugEnterAlt(6);
			// Tiger.g3:1:34: For
			{
			DebugLocation(1, 34);
			mFor(); 

			}
			break;
		case 7:
			DebugEnterAlt(7);
			// Tiger.g3:1:38: Function
			{
			DebugLocation(1, 38);
			mFunction(); 

			}
			break;
		case 8:
			DebugEnterAlt(8);
			// Tiger.g3:1:47: If
			{
			DebugLocation(1, 47);
			mIf(); 

			}
			break;
		case 9:
			DebugEnterAlt(9);
			// Tiger.g3:1:50: In
			{
			DebugLocation(1, 50);
			mIn(); 

			}
			break;
		case 10:
			DebugEnterAlt(10);
			// Tiger.g3:1:53: Let
			{
			DebugLocation(1, 53);
			mLet(); 

			}
			break;
		case 11:
			DebugEnterAlt(11);
			// Tiger.g3:1:57: Nil
			{
			DebugLocation(1, 57);
			mNil(); 

			}
			break;
		case 12:
			DebugEnterAlt(12);
			// Tiger.g3:1:61: Of
			{
			DebugLocation(1, 61);
			mOf(); 

			}
			break;
		case 13:
			DebugEnterAlt(13);
			// Tiger.g3:1:64: Then
			{
			DebugLocation(1, 64);
			mThen(); 

			}
			break;
		case 14:
			DebugEnterAlt(14);
			// Tiger.g3:1:69: To
			{
			DebugLocation(1, 69);
			mTo(); 

			}
			break;
		case 15:
			DebugEnterAlt(15);
			// Tiger.g3:1:72: Type
			{
			DebugLocation(1, 72);
			mType(); 

			}
			break;
		case 16:
			DebugEnterAlt(16);
			// Tiger.g3:1:77: Var
			{
			DebugLocation(1, 77);
			mVar(); 

			}
			break;
		case 17:
			DebugEnterAlt(17);
			// Tiger.g3:1:81: While
			{
			DebugLocation(1, 81);
			mWhile(); 

			}
			break;
		case 18:
			DebugEnterAlt(18);
			// Tiger.g3:1:87: Comma
			{
			DebugLocation(1, 87);
			mComma(); 

			}
			break;
		case 19:
			DebugEnterAlt(19);
			// Tiger.g3:1:93: Colon
			{
			DebugLocation(1, 93);
			mColon(); 

			}
			break;
		case 20:
			DebugEnterAlt(20);
			// Tiger.g3:1:99: Semicolon
			{
			DebugLocation(1, 99);
			mSemicolon(); 

			}
			break;
		case 21:
			DebugEnterAlt(21);
			// Tiger.g3:1:109: LeftParen
			{
			DebugLocation(1, 109);
			mLeftParen(); 

			}
			break;
		case 22:
			DebugEnterAlt(22);
			// Tiger.g3:1:119: RightParen
			{
			DebugLocation(1, 119);
			mRightParen(); 

			}
			break;
		case 23:
			DebugEnterAlt(23);
			// Tiger.g3:1:130: LeftBrack
			{
			DebugLocation(1, 130);
			mLeftBrack(); 

			}
			break;
		case 24:
			DebugEnterAlt(24);
			// Tiger.g3:1:140: RightBrack
			{
			DebugLocation(1, 140);
			mRightBrack(); 

			}
			break;
		case 25:
			DebugEnterAlt(25);
			// Tiger.g3:1:151: LeftBrace
			{
			DebugLocation(1, 151);
			mLeftBrace(); 

			}
			break;
		case 26:
			DebugEnterAlt(26);
			// Tiger.g3:1:161: RightBrace
			{
			DebugLocation(1, 161);
			mRightBrace(); 

			}
			break;
		case 27:
			DebugEnterAlt(27);
			// Tiger.g3:1:172: Dot
			{
			DebugLocation(1, 172);
			mDot(); 

			}
			break;
		case 28:
			DebugEnterAlt(28);
			// Tiger.g3:1:176: Plus
			{
			DebugLocation(1, 176);
			mPlus(); 

			}
			break;
		case 29:
			DebugEnterAlt(29);
			// Tiger.g3:1:181: Minus
			{
			DebugLocation(1, 181);
			mMinus(); 

			}
			break;
		case 30:
			DebugEnterAlt(30);
			// Tiger.g3:1:187: Times
			{
			DebugLocation(1, 187);
			mTimes(); 

			}
			break;
		case 31:
			DebugEnterAlt(31);
			// Tiger.g3:1:193: Divide
			{
			DebugLocation(1, 193);
			mDivide(); 

			}
			break;
		case 32:
			DebugEnterAlt(32);
			// Tiger.g3:1:200: Equal
			{
			DebugLocation(1, 200);
			mEqual(); 

			}
			break;
		case 33:
			DebugEnterAlt(33);
			// Tiger.g3:1:206: NotEqual
			{
			DebugLocation(1, 206);
			mNotEqual(); 

			}
			break;
		case 34:
			DebugEnterAlt(34);
			// Tiger.g3:1:215: LessThan
			{
			DebugLocation(1, 215);
			mLessThan(); 

			}
			break;
		case 35:
			DebugEnterAlt(35);
			// Tiger.g3:1:224: LessEqual
			{
			DebugLocation(1, 224);
			mLessEqual(); 

			}
			break;
		case 36:
			DebugEnterAlt(36);
			// Tiger.g3:1:234: GreaterThan
			{
			DebugLocation(1, 234);
			mGreaterThan(); 

			}
			break;
		case 37:
			DebugEnterAlt(37);
			// Tiger.g3:1:246: GreaterEqual
			{
			DebugLocation(1, 246);
			mGreaterEqual(); 

			}
			break;
		case 38:
			DebugEnterAlt(38);
			// Tiger.g3:1:259: And
			{
			DebugLocation(1, 259);
			mAnd(); 

			}
			break;
		case 39:
			DebugEnterAlt(39);
			// Tiger.g3:1:263: Or
			{
			DebugLocation(1, 263);
			mOr(); 

			}
			break;
		case 40:
			DebugEnterAlt(40);
			// Tiger.g3:1:266: Assign
			{
			DebugLocation(1, 266);
			mAssign(); 

			}
			break;
		case 41:
			DebugEnterAlt(41);
			// Tiger.g3:1:273: Identifier
			{
			DebugLocation(1, 273);
			mIdentifier(); 

			}
			break;
		case 42:
			DebugEnterAlt(42);
			// Tiger.g3:1:284: IntegerLiteral
			{
			DebugLocation(1, 284);
			mIntegerLiteral(); 

			}
			break;
		case 43:
			DebugEnterAlt(43);
			// Tiger.g3:1:299: StringLiteral
			{
			DebugLocation(1, 299);
			mStringLiteral(); 

			}
			break;
		case 44:
			DebugEnterAlt(44);
			// Tiger.g3:1:313: WhiteSpace
			{
			DebugLocation(1, 313);
			mWhiteSpace(); 

			}
			break;
		case 45:
			DebugEnterAlt(45);
			// Tiger.g3:1:324: BlockComment
			{
			DebugLocation(1, 324);
			mBlockComment(); 

			}
			break;
		case 46:
			DebugEnterAlt(46);
			// Tiger.g3:1:337: LineComment
			{
			DebugLocation(1, 337);
			mLineComment(); 

			}
			break;

		}

	}


	#region DFA
	DFA3 dfa3;
	DFA10 dfa10;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa3 = new DFA3(this);
		dfa10 = new DFA10(this);
	}

	private class DFA3 : DFA
	{
		private const string DFA3_eotS =
			"\x28\xFFFF";
		private const string DFA3_eofS =
			"\x28\xFFFF";
		private const string DFA3_minS =
			"\x1\x22\x5\xFFFF\x1\x40\x21\xFFFF";
		private const string DFA3_maxS =
			"\x1\x74\x5\xFFFF\x1\x5F\x21\xFFFF";
		private const string DFA3_acceptS =
			"\x1\xFFFF\x1\x1\x1\x2\x1\x3\x1\x4\x1\x5\x1\xFFFF\x1\x26\x1\x6\x1\x7\x1"+
			"\x8\x1\x9\x1\xA\x1\xB\x1\xC\x1\xD\x1\xE\x1\xF\x1\x10\x1\x11\x1\x12\x1"+
			"\x13\x1\x14\x1\x15\x1\x16\x1\x17\x1\x18\x1\x19\x1\x1A\x1\x1B\x1\x1C\x1"+
			"\x1D\x1\x1E\x1\x1F\x1\x20\x1\x21\x1\x22\x1\x23\x1\x24\x1\x25";
		private const string DFA3_specialS =
			"\x28\xFFFF}>";
		private static readonly string[] DFA3_transitionS =
			{
				"\x1\x4\xD\xFFFF\x3\x7\x29\xFFFF\x1\x5\x1\xFFFF\x1\x6\xF\xFFFF\x1\x2"+
				"\x3\xFFFF\x1\x3\x1\xFFFF\x1\x1",
				"",
				"",
				"",
				"",
				"",
				"\x1\x8\x1\x9\x1\xA\x1\xB\x1\xC\x1\xD\x1\xE\x1\xF\x1\x10\x1\x11\x1\x12"+
				"\x1\x13\x1\x14\x1\x15\x1\x16\x1\x17\x1\x18\x1\x19\x1\x1A\x1\x1B\x1\x1C"+
				"\x1\x1D\x1\x1E\x1\x1F\x1\x20\x1\x21\x1\x22\x1\x23\x1\x24\x1\x25\x1\x26"+
				"\x1\x27",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA3_eot = DFA.UnpackEncodedString(DFA3_eotS);
		private static readonly short[] DFA3_eof = DFA.UnpackEncodedString(DFA3_eofS);
		private static readonly char[] DFA3_min = DFA.UnpackEncodedStringToUnsignedChars(DFA3_minS);
		private static readonly char[] DFA3_max = DFA.UnpackEncodedStringToUnsignedChars(DFA3_maxS);
		private static readonly short[] DFA3_accept = DFA.UnpackEncodedString(DFA3_acceptS);
		private static readonly short[] DFA3_special = DFA.UnpackEncodedString(DFA3_specialS);
		private static readonly short[][] DFA3_transition;

		static DFA3()
		{
			int numStates = DFA3_transitionS.Length;
			DFA3_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA3_transition[i] = DFA.UnpackEncodedString(DFA3_transitionS[i]);
			}
		}

		public DFA3( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 3;
			this.eot = DFA3_eot;
			this.eof = DFA3_eof;
			this.min = DFA3_min;
			this.max = DFA3_max;
			this.accept = DFA3_accept;
			this.special = DFA3_special;
			this.transition = DFA3_transition;
		}

		public override string Description { get { return "509:8: ( 't' | 'n' | 'r' | '\\\"' | '\\\\' | '^@' | '^A' | '^B' | '^C' | '^D' | '^E' | '^F' | '^G' | '^H' | '^I' | '^J' | '^K' | '^L' | '^M' | '^N' | '^O' | '^P' | '^Q' | '^R' | '^S' | '^T' | '^U' | '^V' | '^W' | '^X' | '^Y' | '^Z' | '^[' | '^\\\\' | '^]' | '^^' | '^_' |d1= ( '0' .. '2' ) d2= ( '0' .. '9' ) d3= ( '0' .. '9' ) )"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA10 : DFA
	{
		private const string DFA10_eotS =
			"\x1\xFFFF\xC\x20\x1\xFFFF\x1\x36\xB\xFFFF\x1\x39\x1\xFFFF\x1\x3C\x1\x3E"+
			"\x6\xFFFF\x2\x20\x1\x41\x4\x20\x1\x46\x1\x47\x2\x20\x1\x4A\x1\x20\x1"+
			"\x4C\x3\x20\xA\xFFFF\x2\x20\x1\xFFFF\x1\x20\x1\x53\x1\x54\x1\x20\x2\xFFFF"+
			"\x1\x56\x1\x57\x1\xFFFF\x1\x20\x1\xFFFF\x1\x20\x1\x5A\x3\x20\x1\x5E\x2"+
			"\xFFFF\x1\x20\x2\xFFFF\x1\x60\x1\x61\x1\xFFFF\x1\x20\x1\x63\x1\x64\x1"+
			"\xFFFF\x1\x20\x2\xFFFF\x1\x66\x2\xFFFF\x1\x20\x1\xFFFF\x1\x20\x1\x69"+
			"\x1\xFFFF";
		private const string DFA10_eofS =
			"\x6A\xFFFF";
		private const string DFA10_minS =
			"\x1\x9\x2\x72\x1\x6F\x1\x6C\x1\x6F\x1\x66\x1\x65\x1\x69\x1\x66\x1\x68"+
			"\x1\x61\x1\x68\x1\xFFFF\x1\x3D\xB\xFFFF\x1\x2A\x1\xFFFF\x2\x3D\x6\xFFFF"+
			"\x1\x72\x1\x65\x1\x30\x1\x73\x1\x64\x1\x72\x1\x6E\x2\x30\x1\x74\x1\x6C"+
			"\x1\x30\x1\x65\x1\x30\x1\x70\x1\x72\x1\x69\xA\xFFFF\x2\x61\x1\xFFFF\x1"+
			"\x65\x2\x30\x1\x63\x2\xFFFF\x2\x30\x1\xFFFF\x1\x6E\x1\xFFFF\x1\x65\x1"+
			"\x30\x1\x6C\x1\x79\x1\x6B\x1\x30\x2\xFFFF\x1\x74\x2\xFFFF\x2\x30\x1\xFFFF"+
			"\x1\x65\x2\x30\x1\xFFFF\x1\x69\x2\xFFFF\x1\x30\x2\xFFFF\x1\x6F\x1\xFFFF"+
			"\x1\x6E\x1\x30\x1\xFFFF";
		private const string DFA10_maxS =
			"\x1\x7D\x2\x72\x1\x6F\x1\x6E\x1\x75\x1\x6E\x1\x65\x1\x69\x1\x66\x1\x79"+
			"\x1\x61\x1\x68\x1\xFFFF\x1\x3D\xB\xFFFF\x1\x2F\x1\xFFFF\x1\x3E\x1\x3D"+
			"\x6\xFFFF\x1\x72\x1\x65\x1\x7A\x1\x73\x1\x64\x1\x72\x1\x6E\x2\x7A\x1"+
			"\x74\x1\x6C\x1\x7A\x1\x65\x1\x7A\x1\x70\x1\x72\x1\x69\xA\xFFFF\x2\x61"+
			"\x1\xFFFF\x1\x65\x2\x7A\x1\x63\x2\xFFFF\x2\x7A\x1\xFFFF\x1\x6E\x1\xFFFF"+
			"\x1\x65\x1\x7A\x1\x6C\x1\x79\x1\x6B\x1\x7A\x2\xFFFF\x1\x74\x2\xFFFF\x2"+
			"\x7A\x1\xFFFF\x1\x65\x2\x7A\x1\xFFFF\x1\x69\x2\xFFFF\x1\x7A\x2\xFFFF"+
			"\x1\x6F\x1\xFFFF\x1\x6E\x1\x7A\x1\xFFFF";
		private const string DFA10_acceptS =
			"\xD\xFFFF\x1\x12\x1\xFFFF\x1\x14\x1\x15\x1\x16\x1\x17\x1\x18\x1\x19\x1"+
			"\x1A\x1\x1B\x1\x1C\x1\x1D\x1\x1E\x1\xFFFF\x1\x20\x2\xFFFF\x1\x26\x1\x27"+
			"\x1\x29\x1\x2A\x1\x2B\x1\x2C\x11\xFFFF\x1\x28\x1\x13\x1\x2D\x1\x2E\x1"+
			"\x1F\x1\x21\x1\x23\x1\x22\x1\x25\x1\x24\x2\xFFFF\x1\x3\x4\xFFFF\x1\x8"+
			"\x1\x9\x2\xFFFF\x1\xC\x1\xFFFF\x1\xE\x6\xFFFF\x1\x5\x1\x6\x1\xFFFF\x1"+
			"\xA\x1\xB\x2\xFFFF\x1\x10\x3\xFFFF\x1\x4\x1\xFFFF\x1\xD\x1\xF\x1\xFFFF"+
			"\x1\x1\x1\x2\x1\xFFFF\x1\x11\x2\xFFFF\x1\x7";
		private const string DFA10_specialS =
			"\x6A\xFFFF}>";
		private static readonly string[] DFA10_transitionS =
			{
				"\x2\x23\x2\xFFFF\x1\x23\x12\xFFFF\x1\x23\x1\xFFFF\x1\x22\x3\xFFFF\x1"+
				"\x1E\x1\xFFFF\x1\x10\x1\x11\x1\x19\x1\x17\x1\xD\x1\x18\x1\x16\x1\x1A"+
				"\xA\x21\x1\xE\x1\xF\x1\x1C\x1\x1B\x1\x1D\x2\xFFFF\x1A\x20\x1\x12\x1"+
				"\xFFFF\x1\x13\x3\xFFFF\x1\x1\x1\x2\x1\x20\x1\x3\x1\x4\x1\x5\x2\x20\x1"+
				"\x6\x2\x20\x1\x7\x1\x20\x1\x8\x1\x9\x4\x20\x1\xA\x1\x20\x1\xB\x1\xC"+
				"\x3\x20\x1\x14\x1\x1F\x1\x15",
				"\x1\x24",
				"\x1\x25",
				"\x1\x26",
				"\x1\x27\x1\xFFFF\x1\x28",
				"\x1\x29\x5\xFFFF\x1\x2A",
				"\x1\x2B\x7\xFFFF\x1\x2C",
				"\x1\x2D",
				"\x1\x2E",
				"\x1\x2F",
				"\x1\x30\x6\xFFFF\x1\x31\x9\xFFFF\x1\x32",
				"\x1\x33",
				"\x1\x34",
				"",
				"\x1\x35",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\x37\x4\xFFFF\x1\x38",
				"",
				"\x1\x3B\x1\x3A",
				"\x1\x3D",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\x3F",
				"\x1\x40",
				"\xA\x20\x7\xFFFF\x1A\x20\x4\xFFFF\x1\x20\x1\xFFFF\x1A\x20",
				"\x1\x42",
				"\x1\x43",
				"\x1\x44",
				"\x1\x45",
				"\xA\x20\x7\xFFFF\x1A\x20\x4\xFFFF\x1\x20\x1\xFFFF\x1A\x20",
				"\xA\x20\x7\xFFFF\x1A\x20\x4\xFFFF\x1\x20\x1\xFFFF\x1A\x20",
				"\x1\x48",
				"\x1\x49",
				"\xA\x20\x7\xFFFF\x1A\x20\x4\xFFFF\x1\x20\x1\xFFFF\x1A\x20",
				"\x1\x4B",
				"\xA\x20\x7\xFFFF\x1A\x20\x4\xFFFF\x1\x20\x1\xFFFF\x1A\x20",
				"\x1\x4D",
				"\x1\x4E",
				"\x1\x4F",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\x50",
				"\x1\x51",
				"",
				"\x1\x52",
				"\xA\x20\x7\xFFFF\x1A\x20\x4\xFFFF\x1\x20\x1\xFFFF\x1A\x20",
				"\xA\x20\x7\xFFFF\x1A\x20\x4\xFFFF\x1\x20\x1\xFFFF\x1A\x20",
				"\x1\x55",
				"",
				"",
				"\xA\x20\x7\xFFFF\x1A\x20\x4\xFFFF\x1\x20\x1\xFFFF\x1A\x20",
				"\xA\x20\x7\xFFFF\x1A\x20\x4\xFFFF\x1\x20\x1\xFFFF\x1A\x20",
				"",
				"\x1\x58",
				"",
				"\x1\x59",
				"\xA\x20\x7\xFFFF\x1A\x20\x4\xFFFF\x1\x20\x1\xFFFF\x1A\x20",
				"\x1\x5B",
				"\x1\x5C",
				"\x1\x5D",
				"\xA\x20\x7\xFFFF\x1A\x20\x4\xFFFF\x1\x20\x1\xFFFF\x1A\x20",
				"",
				"",
				"\x1\x5F",
				"",
				"",
				"\xA\x20\x7\xFFFF\x1A\x20\x4\xFFFF\x1\x20\x1\xFFFF\x1A\x20",
				"\xA\x20\x7\xFFFF\x1A\x20\x4\xFFFF\x1\x20\x1\xFFFF\x1A\x20",
				"",
				"\x1\x62",
				"\xA\x20\x7\xFFFF\x1A\x20\x4\xFFFF\x1\x20\x1\xFFFF\x1A\x20",
				"\xA\x20\x7\xFFFF\x1A\x20\x4\xFFFF\x1\x20\x1\xFFFF\x1A\x20",
				"",
				"\x1\x65",
				"",
				"",
				"\xA\x20\x7\xFFFF\x1A\x20\x4\xFFFF\x1\x20\x1\xFFFF\x1A\x20",
				"",
				"",
				"\x1\x67",
				"",
				"\x1\x68",
				"\xA\x20\x7\xFFFF\x1A\x20\x4\xFFFF\x1\x20\x1\xFFFF\x1A\x20",
				""
			};

		private static readonly short[] DFA10_eot = DFA.UnpackEncodedString(DFA10_eotS);
		private static readonly short[] DFA10_eof = DFA.UnpackEncodedString(DFA10_eofS);
		private static readonly char[] DFA10_min = DFA.UnpackEncodedStringToUnsignedChars(DFA10_minS);
		private static readonly char[] DFA10_max = DFA.UnpackEncodedStringToUnsignedChars(DFA10_maxS);
		private static readonly short[] DFA10_accept = DFA.UnpackEncodedString(DFA10_acceptS);
		private static readonly short[] DFA10_special = DFA.UnpackEncodedString(DFA10_specialS);
		private static readonly short[][] DFA10_transition;

		static DFA10()
		{
			int numStates = DFA10_transitionS.Length;
			DFA10_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA10_transition[i] = DFA.UnpackEncodedString(DFA10_transitionS[i]);
			}
		}

		public DFA10( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 10;
			this.eot = DFA10_eot;
			this.eof = DFA10_eof;
			this.min = DFA10_min;
			this.max = DFA10_max;
			this.accept = DFA10_accept;
			this.special = DFA10_special;
			this.transition = DFA10_transition;
		}

		public override string Description { get { return "1:1: Tokens : ( Array | Break | Do | Else | End | For | Function | If | In | Let | Nil | Of | Then | To | Type | Var | While | Comma | Colon | Semicolon | LeftParen | RightParen | LeftBrack | RightBrack | LeftBrace | RightBrace | Dot | Plus | Minus | Times | Divide | Equal | NotEqual | LessThan | LessEqual | GreaterThan | GreaterEqual | And | Or | Assign | Identifier | IntegerLiteral | StringLiteral | WhiteSpace | BlockComment | LineComment );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

 
	#endregion

}

} // namespace NaiveTigerCompiler
